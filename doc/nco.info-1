This is nco.info, produced by makeinfo version 4.13 from nco.texi.

INFO-DIR-SECTION netCDF
START-INFO-DIR-ENTRY
* NCO::        User's Guide for the netCDF Operator suite
END-INFO-DIR-ENTRY

   This file documents NCO, a collection of utilities to manipulate and
analyze netCDF files.

   Copyright (C) 1995-2010 Charlie Zender

   This is the first edition of the `NCO User's Guide',
and is consistent with version 2 of `texinfo.tex'.

   Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts. The
license is available online at `http://www.gnu.org/copyleft/fdl.html'

   The original author of this software, Charlie Zender, wants to
improve it with the help of your suggestions, improvements,
bug-reports, and patches.
Charlie Zender <surname at uci dot edu> (yes, my surname is zender)
3200 Croul Hall
Department of Earth System Science
University of California, Irvine
Irvine, CA 92697-3100

File: nco.info,  Node: Top,  Next: Foreword,  Prev: (dir),  Up: (dir)

NCO User's Guide
****************

_Note to readers of the NCO User's Guide in Info format_: _The NCO
User's Guide in PDF format (./nco.pdf) (also on SourceForge
(http://nco.sf.net/nco.pdf)) contains the complete NCO documentation._
This Info documentation is equivalent except it refers you to the
printed (i.e., DVI, PostScript, and PDF) documentation for description
of complex mathematical expressions.

The netCDF Operators, or NCO, are a suite of programs known as
operators.  The operators facilitate manipulation and analysis of data
stored in the self-describing netCDF format, available from
(`http://www.unidata.ucar.edu/packages/netcdf').  Each NCO operator
(e.g., ncks) takes netCDF input file(s), performs an operation (e.g.,
averaging, hyperslabbing, or renaming), and outputs a processed netCDF
file.  Although most users of netCDF data are involved in scientific
research, these data formats, and thus NCO, are generic and are equally
useful in fields from agriculture to zoology.  The NCO User's Guide
illustrates NCO use with examples from the field of climate modeling
and analysis.  The NCO homepage is `http://nco.sf.net', and there is a
mirror at `http://dust.ess.uci.edu/nco'.

   This documentation is for NCO version 4.0.2.  It was last updated
5 April 2010.  Corrections, additions, and rewrites of this
documentation are very welcome.

   Enjoy,
Charlie Zender

* Menu:

* Foreword::
* Summary::
* Introduction::
* Strategies::
* Common features::
* Operator Reference Manual::
* Contributing::
* CCSM Example::
* mybibnode::
* General Index::


File: nco.info,  Node: Foreword,  Next: Summary,  Prev: Top,  Up: Top

Foreword
********

NCO is the result of software needs that arose while I worked on
projects funded by NCAR, NASA, and ARM.  Thinking they might prove
useful as tools or templates to others, it is my pleasure to provide
them freely to the scientific community.  Many users (most of whom I
have never met) have encouraged the development of NCO.  Thanks
espcially to Jan Polcher, Keith Lindsay, Arlindo da Silva, John
Sheldon, and William Weibel for stimulating suggestions and
correspondence.  Your encouragment motivated me to complete the `NCO
User's Guide'.  So if you like NCO, send me a note!  I should mention
that NCO is not connected to or officially endorsed by Unidata, ACD,
ASP, CGD, or Nike.

Charlie Zender
May 1997
Boulder, Colorado


Major feature improvements entitle me to write another Foreword.  In
the last five years a lot of work has been done to refine NCO.  NCO is
now an open source project and appears to be much healthier for it.
The list of illustrious institutions that do not endorse NCO continues
to grow, and now includes UCI.

Charlie Zender
October 2000
Irvine, California


The most remarkable advances in NCO capabilities in the last few years
are due to contributions from the Open Source community.  Especially
noteworthy are the contributions of Henry Butowsky and Rorik Peterson.

Charlie Zender
January 2003
Irvine, California


NCO has been generously supported from 2004-2008 by US National Science
Foundation (NSF) grant IIS-0431203
(http://www.nsf.gov/awardsearch/showAward.do?AwardNumber=0431203).
This support allowed me to maintain and extend core NCO code, and
others to advance NCO in new directions: Gayathri Venkitachalam helped
implement MPI; Harry Mangalam improved regression testing and
benchmarking; Daniel Wang developed the server-side capability, SWAMP;
and Henry Butowsky, a long-time contributor, developed `ncap2'.  This
support also led NCO to debut in professional journals and meetings.
The personal and professional contacts made during this evolution have
been immensely rewarding.

Charlie Zender
March 2008
Grenoble, France

File: nco.info,  Node: Summary,  Next: Introduction,  Prev: Foreword,  Up: Top

Summary
*******

This manual describes NCO, which stands for netCDF Operators.  NCO is a
suite of programs known as "operators".  Each operator is a standalone,
command line program executed at the shell-level like, e.g., `ls' or
`mkdir'.  The operators take netCDF files (including HDF5 files
constructed using the netCDF API) as input, perform an operation (e.g.,
averaging or hyperslabbing), and produce a netCDF file as output.  The
operators are primarily designed to aid manipulation and analysis of
data.  The examples in this documentation are typical applications of
the operators for processing climate model output.  This stems from
their origin, though the operators are as general as netCDF itself.


File: nco.info,  Node: Introduction,  Next: Strategies,  Prev: Summary,  Up: Top

1 Introduction
**************

* Menu:

* Availability::
* Compatability::
* Libraries::
* netCDF2/3/4 and HDF4/5 Support::
* Help Requests and Bug Reports::


File: nco.info,  Node: Availability,  Next: Compatability,  Prev: Introduction,  Up: Introduction

1.1 Availability
================

The complete NCO source distribution is currently distributed as a
"compressed tarfile" from `http://sf.net/projects/nco' and from
`http://dust.ess.uci.edu/nco/nco.tar.gz'.  The compressed tarfile must
be uncompressed and untarred before building NCO.  Uncompress the file
with `gunzip nco.tar.gz'.  Extract the source files from the resulting
tarfile with `tar -xvf nco.tar'.  GNU `tar' lets you perform both
operations in one step with `tar -xvzf nco.tar.gz'.

   The documentation for NCO is called the `NCO User's Guide'.  The
`User's Guide' is available in Postscript, HTML, DVI, TeXinfo, and Info
formats.  These formats are included in the source distribution in the
files `nco.ps', `nco.html', `nco.dvi', `nco.texi', and `nco.info*',
respectively.  All the documentation descends from a single source file,
`nco.texi' (1).  Hence the documentation in every format is very
similar.  However, some of the complex mathematical expressions needed
to describe `ncwa' can only be displayed in DVI, Postscript, and PDF
formats.

   A complete list of papers and publications on/about NCO is available
on the NCO homepage.  Most of these are freely available.  The primary
refereed publications are fxm ZeM06 and fxm Zen07.  These contain
copyright restrictions which limit their redistribution, but they are
freely available in preprint form from the NCO.

   If you want to quickly see what the latest improvements in NCO are
(without downloading the entire source distribution), visit the NCO
homepage at `http://nco.sf.net'.  The HTML version of the `User's
Guide' is also available online through the World Wide Web at URL
`http://nco.sf.net/nco.html'.  To build and use NCO, you must have
netCDF installed.  The netCDF homepage is
`http://www.unidata.ucar.edu/packages/netcdf'.

   New NCO releases are announced on the netCDF list and on the
`nco-announce' mailing list
`http://lists.sf.net/mailman/listinfo/nco-announce'.

   ---------- Footnotes ----------

   (1) To produce these formats, `nco.texi' was simply run through the
freely available programs `texi2dvi', `dvips', `texi2html', and
`makeinfo'.  Due to a bug in TeX, the resulting Postscript file,
`nco.ps', contains the Table of Contents as the final pages.  Thus if
you print `nco.ps', remember to insert the Table of Contents after the
cover sheet before you staple the manual.


File: nco.info,  Node: Compatability,  Next: Libraries,  Prev: Availability,  Up: Introduction

1.2 Operating systems compatible with NCO
=========================================

NCO has been successfully ported and tested and is known to work on the
following 32- and 64-bit platforms: IBM AIX 4.x, 5.x, FreeBSD 4.x,
GNU/Linux 2.x, LinuxPPC, LinuxAlpha, LinuxARM, LinuxSparc64, SGI IRIX
5.x and 6.x, MacOS X 10.x, NEC Super-UX 10.x, DEC OSF, Sun SunOS 4.1.x,
Solaris 2.x, Cray UNICOS 8.x-10.x, and MS Windows95 and all later
versions.  If you port the code to a new operating system, please send
me a note and any patches you required.

   The major prerequisite for installing NCO on a particular platform
is the successful, prior installation of the netCDF library (and, as of
2003, the UDUnits library).  Unidata has shown a commitment to
maintaining netCDF and UDUnits on all popular UNIX platforms, and is
moving towards full support for the Microsoft Windows operating system
(OS).  Given this, the only difficulty in implementing NCO on a
particular platform is standardization of various C and Fortran
interface and system calls.  NCO code is tested for ANSI compliance by
compiling with C compilers including those from GNU (`gcc -std=c99
-pedantic -D_BSD_SOURCE -D_POSIX_SOURCE' -Wall) (1), Comeau Computing
(`como --c99'), Cray (`cc'), HP/Compaq/DEC (`cc'), IBM (`xlc -c
-qlanglvl=extc99'), Intel (`icc -std=c99'), NEC (`cc'), PathScale
(QLogic) (`pathcc -std=c99'), PGI (`pgcc -c9x'), SGI (`cc -c99'), and
Sun (`cc').  NCO (all commands and the `libnco' library) and the C++
interface to netCDF (called `libnco_c++') comply with the ISO C++
standards as implemented by Comeau Computing (`como'), Cray (`CC'), GNU
(`g++ -Wall'), HP/Compaq/DEC (`cxx'), IBM (`xlC'), Intel (`icc'), NEC
(`c++'), PathScale (Qlogic) (`pathCC'), PGI (`pgCC'), SGI (`CC
-LANG:std'), and Sun (`CC -LANG:std').  See `nco/bld/Makefile' and
`nco/src/nco_c++/Makefile.old' for more details and exact settings.

   Until recently (and not even yet), ANSI-compliant has meant
compliance with the 1989 ISO C-standard, usually called C89 (with minor
revisions made in 1994 and 1995).  C89 lacks variable-size arrays,
restricted pointers, some useful `printf' formats, and many
mathematical special functions.  These are valuable features of C99,
the 1999 ISO C-standard.  NCO is C99-compliant where possible and
C89-compliant where necessary.  Certain branches in the code are
required to satisfy the native SGI and SunOS C compilers, which are
strictly ANSI C89 compliant, and cannot benefit from C99 features.
However, C99 features are fully supported by modern AIX, GNU, Intel,
NEC, Solaris, and UNICOS compilers.  NCO requires a C99-compliant
compiler as of NCO version 2.9.8, released in August, 2004.

   The most time-intensive portion of NCO execution is spent in
arithmetic operations, e.g., multiplication, averaging, subtraction.
These operations were performed in Fortran by default until August,
1999.  This was a design decision based on the relative speed of
Fortran-based object code vs. C-based object code in late 1994.
C compiler vectorization capabilities have dramatically improved since
1994.  We have accordingly replaced all Fortran subroutines with
C functions.  This greatly simplifies the task of building NCO on
nominally unsupported platforms.  As of August 1999, NCO built entirely
in C by default.  This allowed NCO to compile on any machine with an
ANSI C compiler.  In August 2004, the first C99 feature, the `restrict'
type qualifier, entered NCO in version 2.9.8.  C compilers can obtain
better performance with C99 restricted pointers since they inform the
compiler when it may make Fortran-like assumptions regarding pointer
contents alteration.  Subsequently, NCO requires a C99 compiler to
build correctly (2).

   In January 2009, NCO version 3.9.6 was the first to link to the GNU
Scientific Library (GSL).  GSL must be version 1.4 or later.  NCO, in
particular `ncap2', uses the GSL special function library to evaluate
geoscience-relevant mathematics such as Bessel functions, Legendre
polynomials, and incomplete gamma functions (*note GSL special
functions::).

   In June 2005, NCO version 3.0.1 began to take advantage of C99
mathematical special functions.  These include the standarized gamma
function (called `tgamma()' for "true gamma").  NCO automagically takes
advantage of some GNU Compiler Collection (GCC) extensions to ANSI C.

   As of July 2000 and NCO version 1.2, NCO no longer performs
arithmetic operations in Fortran.  We decided to sacrifice executable
speed for code maintainability.  Since no objective statistics were
ever performed to quantify the difference in speed between the Fortran
and C code, the performance penalty incurred by this decision is
unknown.  Supporting Fortran involves maintaining two sets of routines
for every arithmetic operation.  The `USE_FORTRAN_ARITHMETIC' flag is
still retained in the `Makefile'.  The file containing the Fortran
code, `nco_fortran.F', has been deprecated but a volunteer
(Dr. Frankenstein?) could resurrect it.  If you would like to volunteer
to maintain `nco_fortran.F' please contact me.

* Menu:

* Windows Operating System::

   ---------- Footnotes ----------

   (1) The `_BSD_SOURCE' token is required on some Linux platforms where
`gcc' dislikes the network header files like `netinet/in.h').

   (2) NCO may still build with an ANSI or ISO C89 or C94/95-compliant
compiler if the C pre-processor undefines the `restrict' type
qualifier, e.g., by invoking the compiler with `-Drestrict='''.


File: nco.info,  Node: Windows Operating System,  Prev: Compatability,  Up: Compatability

1.2.1 Compiling NCO for Microsoft Windows OS
--------------------------------------------

NCO has been successfully ported and tested on the Microsoft Windows
(95/98/NT/2000/XP) operating systems.  The switches necessary to
accomplish this are included in the standard distribution of NCO.
Using the freely available Cygwin (formerly gnu-win32) development
environment (1), the compilation process is very similar to installing
NCO on a UNIX system.  Set the `PVM_ARCH' preprocessor token to `WIN32'.
Note that defining `WIN32' has the side effect of disabling Internet
features of NCO (see below).  NCO should now build like it does on UNIX.

   The least portable section of the code is the use of standard UNIX
and Internet protocols (e.g., `ftp', `rcp', `scp', `sftp', `getuid',
`gethostname', and header files `<arpa/nameser.h>' and `<resolv.h>').  Fortunately,
these UNIX-y calls are only invoked by the single NCO subroutine which
is responsible for retrieving files stored on remote systems (*note
Remote storage::).  In order to support NCO on the Microsoft Windows
platforms, this single feature was disabled (on Windows OS only).  This
was required by Cygwin 18.x--newer versions of Cygwin may support these
protocols (let me know if this is the case).  The NCO operators should
behave identically on Windows and UNIX platforms in all other respects.

   ---------- Footnotes ----------

   (1) The Cygwin package is available from
`http://sourceware.redhat.com/cygwin'
Currently, Cygwin 20.x comes with the GNU C/C++/Fortran compilers
(`gcc', `g++', `g77').  These GNU compilers may be used to build the
netCDF distribution itself.


File: nco.info,  Node: Libraries,  Next: netCDF2/3/4 and HDF4/5 Support,  Prev: Compatability,  Up: Introduction

1.3 Libraries
=============

Like all executables, the NCO operators can be built using dynamic
linking.  This reduces the size of the executable and can result in
significant performance enhancements on multiuser systems.
Unfortunately, if your library search path (usually the
`LD_LIBRARY_PATH' environment variable) is not set correctly, or if the
system libraries have been moved, renamed, or deleted since NCO was
installed, it is possible NCO operators will fail with a message that
they cannot find a dynamically loaded (aka "shared object" or `.so')
library.  This will produce a distinctive error message, such as
`ld.so.1: /usr/local/bin/ncea: fatal: libsunmath.so.1: can't open file:
errno=2'.  If you received an error message like this, ask your system
administrator to diagnose whether the library is truly missing (1), or
whether you simply need to alter your library search path.  As a final
remedy, you may re-compile and install NCO with all operators
statically linked.

   ---------- Footnotes ----------

   (1) The `ldd' command, if it is available on your system, will tell
you where the executable is looking for each dynamically loaded
library. Use, e.g., `ldd `which ncea`'.


File: nco.info,  Node: netCDF2/3/4 and HDF4/5 Support,  Next: Help Requests and Bug Reports,  Prev: Libraries,  Up: Introduction

1.4 netCDF2/3/4 and HDF4/5 Support
==================================

netCDF version 2 was released in 1993.  NCO (specifically `ncks') began
soon after this in 1994.  netCDF 3.0 was released in 1996, and we were
eager to reap the performance advantages of the newer netCDF
implementation.  One netCDF3 interface call (`nc_inq_libvers') was
added to NCO in January, 1998, to aid in maintainance and debugging.
In March, 2001, the final conversion of NCO to netCDF3 was completed
(coincidentally on the same day netCDF 3.5 was released).  NCO
versions 2.0 and higher are built with the `-DNO_NETCDF_2' flag to
ensure no netCDF2 interface calls are used.  

   However, the ability to compile NCO with only netCDF2 calls is worth
maintaining because HDF version 4 (1) (available from HDF
(http://hdf.ncsa.uiuc.edu)) supports only the netCDF2 library calls
(see `http://hdf.ncsa.uiuc.edu/UG41r3_html/SDS_SD.fm12.html#47784').
Note that there are multiple versions of HDF.  Currently HDF
version 4.x supports netCDF2 and thus NCO version 1.2.x.  If NCO
version 1.2.x (or earlier) is built with only netCDF2 calls then all
NCO operators should work with HDF4 files as well as netCDF files (2).  The
preprocessor token `NETCDF2_ONLY' exists in NCO version 1.2.x to
eliminate all netCDF3 calls.  Only versions of NCO numbered 1.2.x and
earlier have this capability.  The NCO 1.2.x branch will be maintained
with bugfixes only (no new features) until HDF begins to fully support
the netCDF3 interface (which is employed by NCO 2.x).  If, at
compilation time, `NETCDF2_ONLY' is defined, then NCO version 1.2.x
will not use any netCDF3 calls and, if linked properly, the resulting
NCO operators will work with HDF4 files.  The `Makefile' supplied with
NCO 1.2.x is written to simplify building in this HDF capability.  When
NCO is built with `make HDF4=Y', the `Makefile' sets all required
preprocessor flags and library links to build with the HDF4 libraries
(which are assumed to reside under `/usr/local/hdf4', edit the
`Makefile' to suit your installation).

   HDF version 5 became available in 1999, but did not support netCDF
(or, for that matter, Fortran) as of December 1999.  By early 2001,
HDF5 did support Fortran90.  In 2004, Unidata and NCSA began a project
to implement the HDF5 features necessary to support the netCDF API.
NCO version 3.0.3 added support for reading/writing netCDF4-formatted
HDF5 files in October, 2005.  See *note Selecting Output File Format::
for more details.

   HDF support for netCDF was completed with HDF5 version version 1.8
in 2007.  The netCDF front-end that uses this HDF5 back-end was
completed and released soon after as netCDF version 4.  Download it
from the netCDF4
(http://my.unidata.ucar.edu/content/software/netcdf/netcdf-4) website.

   NCO version 3.9.0 added support for all netCDF4 atomic data types
except `NC_STRING' in May, 2007.  Support for additional netCDF4
features has been incremental.  We add one netCDF4 feature at a time.
You must build NCO with netCDF4 to obtain this support.

   The main netCDF4 features that NCO currently supports are the new
atomic data types, Lempel-Ziv compression, and chunking.  The new
atomic data types are `NC_UBYTE', `NC_USHORT', `NC_UINT', `NC_INT64',
and `NC_UINT64'.  Eight-byte integer support is an especially useful
improvement from netCDF3.  All NCO operators support these types, e.g.,
`ncks' copies and prints them, `ncra' averages them, and `ncap2'
processes algebraic scripts with them.  `ncks' prints compression
information, if any, to screen.

   NCO version 3.9.9 (June, 2009) added support for the `NC_STRING'
netCDF4 atomic data type.  Ragged arrays of strings are supported.

   NCO version 3.9.1 (June, 2007) added support for netCDF4 Lempel-Ziv
deflation.  Lempel-Ziv deflation is a lossless compression technique.
See *note Deflation:: for more details.

   NCO version 3.9.9 (June, 2009) added support for netCDF4 chunking.
See *note Chunking:: for more details.

   netCDF4-enabled NCO handles netCDF3 files without change.  In
addition, it automagically handles netCDF4 (HDF5) files: If you feed
NCO netCDF3 files, it produces netCDF3 output.  If you feed NCO netCDF4
files, it produces netCDF4 output.  Use the handy-dandy `-4' switch to
request netCDF4 output from netCDF3 input, i.e., to convert netCDF3 to
netCDF4.  See *note Selecting Output File Format:: for more details.

   Use appropriate caution while netCDF4 is beta software.  Problems
with netCDF4 and HDF libraries are still being fixed.  NCO support for
netCDF4 atomic types is relatively untested.  Binary NCO distributions
(RPMs and debs) still use netCDF3.

   For now you must build NCO from source to get netCDF4 support.
Typically, one specifies the root of the netCDF4-beta installation
directory. Do this with the `NETCDF4_ROOT' variable.  Then use your
preferred NCO build mechanism, e.g.,
     export NETCDF4_ROOT=/usr/local/netcdf4 # Set netCDF4 location
     cd ~/nco;./configure --enable-netcdf4  # Configure mechanism -or-
     cd ~/nco/bld;./make NETCDF4=Y allinone # Old Makefile mechanism

   Our short term goal is to track the netCDF4-beta releases, keep the
new netCDF4 atomic type support working, and iron out any problems.
Our long term goal is to utilize more of the extensive new netCDF4
feature set. The next major netCDF4 feature we are likely to utilize is
parallel I/O. We will enable this in the MPI netCDF operators.

   ---------- Footnotes ----------

   (1) The Hierarchical Data Format, or HDF, is another self-describing
data format similar to, but more elaborate than, netCDF.

   (2) One must link the NCO code to the HDF4 MFHDF library instead of
the usual netCDF library.  Does `MF' stands for Mike Folk?  Perhaps.
In any case, the MFHDF library only supports netCDF2 calls.  Thus I
will try to keep this capability in NCO as long as it is not too much
trouble.


File: nco.info,  Node: Help Requests and Bug Reports,  Prev: netCDF2/3/4 and HDF4/5 Support,  Up: Introduction

1.5 Help Requests and Bug Reports
=================================

We generally receive three categories of mail from users: help requests,
bug reports, and feature requests.  Notes saying the equivalent of
"Hey, NCO continues to work great and it saves me more time everyday
than it took to write this note" are a distant fourth.

   There is a different protocol for each type of request.  The
preferred etiquette for all communications is via NCO Project Forums.
Do not contact project members via personal e-mail unless your request
comes with money or you have damaging information about our personal
lives.  _Please use the Forums_--they preserve a record of the questions
and answers so that others can learn from our exchange.  Also, since
NCO is government-funded, this record helps us provide program officers
with information they need to evaluate our project.

   Before posting to the NCO forums described below, you might first
register (https://sf.net/account/register.php) your name and email
address with SourceForge.net or else all of your postings will be
attributed to "nobody".  Once registered you may choose to "monitor"
any forum and to receive (or not) email when there are any postings
including responses to your questions.  We usually reply to the forum
message, not to the original poster.

   If you want us to include a new feature in NCO, check first to see
if that feature is already on the TODO (file:./TODO) list.  If it is,
why not implement that feature yourself and send us the patch?  If the
feature is not yet on the list, then send a note to the NCO Discussion
forum (http://sf.net/forum/forum.php?forum_id=9829).

   Read the manual before reporting a bug or posting a help request.
Sending questions whose answers are not in the manual is the best way
to motivate us to write more documentation.  We would also like to
accentuate the contrapositive of this statement.  If you think you have
found a real bug _the most helpful thing you can do is simplify the
problem to a manageable size and then report it_.  The first thing to
do is to make sure you are running the latest publicly released version
of NCO.

   Once you have read the manual, if you are still unable to get NCO to
perform a documented function, submit a help request.  Follow the same
procedure as described below for reporting bugs (after all, it might be
a bug).  That is, describe what you are trying to do, and include the
complete commands (run with `-D 5'), error messages, and version of NCO
(with `-r').  Post your help request to the NCO Help forum
(http://sf.net/forum/forum.php?forum_id=9830).

   If you think you used the right command when NCO misbehaves, then
you might have found a bug.  Incorrect numerical answers are the
highest priority.  We usually fix those within one or two days.  Core
dumps and sementation violations receive lower priority.  They are
always fixed, eventually.

   How do you simplify a problem that reveal a bug?  Cut out extraneous
variables, dimensions, and metadata from the offending files and re-run
the command until it no longer breaks.  Then back up one step and
report the problem.  Usually the file(s) will be very small, i.e., one
variable with one or two small dimensions ought to suffice.  Run the
operator with `-r' and then run the command with `-D 5' to increase the
verbosity of the debugging output.  It is very important that your
report contain the exact error messages and compile-time environment.
Include a copy of your sample input file, or place one on a publically
accessible location, of the file(s).  Post the full bug report to the
NCO Project buglist (http://sf.net/bugs/?group_id=3331).

   Build failures count as bugs.  Our limited machine access means we
cannot fix all build failures.  The information we need to diagnose,
and often fix, build failures are the three files output by GNU build
tools, `nco.config.log.${GNU_TRP}.foo', `nco.configure.${GNU_TRP}.foo',
and `nco.make.${GNU_TRP}.foo'.  The file `configure.eg' shows how to
produce these files.  Here `${GNU_TRP}' is the "GNU architecture
triplet", the CHIP-VENDOR-OS string returned by `config.guess'.  Please
send us your improvements to the examples supplied in `configure.eg'.  The
regressions archive at `http://dust.ess.uci.edu/nco/rgr' contains the
build output from our standard test systems.  You may find you can
solve the build problem yourself by examining the differences between
these files and your own.


File: nco.info,  Node: Strategies,  Next: Common features,  Prev: Introduction,  Up: Top

2 Operator Strategies
*********************

* Menu:

* Philosophy::
* Climate Model Paradigm::
* Temporary Output Files::
* Appending Variables::
* Simple Arithmetic and Interpolation::
* Averaging vs. Concatenating::
* Large Numbers of Files::
* Large Datasets::
* Memory Requirements::
* Performance::


File: nco.info,  Node: Philosophy,  Next: Climate Model Paradigm,  Prev: Strategies,  Up: Strategies

2.1 Philosophy
==============

The main design goal is command line operators which perform useful,
scriptable operations on netCDF files.  Many scientists work with
models and observations which produce too much data to analyze in
tabular format.  Thus, it is often natural to reduce and massage this
raw or primary level data into summary, or second level data, e.g.,
temporal or spatial averages.  These second level data may become the
inputs to graphical and statistical packages, and are often more
suitable for archival and dissemination to the scientific community.
NCO performs a suite of operations useful in manipulating data from the
primary to the second level state.  Higher level interpretive languages
(e.g., IDL, Yorick, Matlab, NCL, Perl, Python), and lower level
compiled languages (e.g., C, Fortran) can always perform any task
performed by NCO, but often with more overhead.  NCO, on the other
hand, is limited to a much smaller set of arithmetic and metadata
operations than these full blown languages.

   Another goal has been to implement enough command line switches so
that frequently used sequences of these operators can be executed from a
shell script or batch file.  Finally, NCO was written to consume the
absolute minimum amount of system memory required to perform a given
job.  The arithmetic operators are extremely efficient; their exact
memory usage is detailed in *note Memory Requirements::.


File: nco.info,  Node: Climate Model Paradigm,  Next: Temporary Output Files,  Prev: Philosophy,  Up: Strategies

2.2 Climate Model Paradigm
==========================

NCO was developed at NCAR to aid analysis and manipulation of datasets
produced by General Circulation Models (GCMs).  Datasets produced by
GCMs share many features with all gridded scientific datasets and so
provide a useful paradigm for the explication of the NCO operator set.
Examples in this manual use a GCM paradigm because latitude, longitude,
time, temperature and other fields related to our natural environment
are as easy to visualize for the layman as the expert.


File: nco.info,  Node: Temporary Output Files,  Next: Appending Variables,  Prev: Climate Model Paradigm,  Up: Strategies

2.3 Temporary Output Files
==========================

NCO operators are designed to be reasonably fault tolerant, so that if
there is a system failure or the user aborts the operation (e.g., with
`C-c'), then no data are lost.  The user-specified OUTPUT-FILE is only
created upon successful completion of the operation (1).  This is
accomplished by performing all operations in a temporary copy of
OUTPUT-FILE.  The name of the temporary output file is constructed by
appending `.pid<PROCESS ID>.<OPERATOR NAME>.tmp' to the user-specified
OUTPUT-FILE name.  When the operator completes its task with no fatal
errors, the temporary output file is moved to the user-specified
OUTPUT-FILE.  Note the construction of a temporary output file uses
more disk space than just overwriting existing files "in place"
(because there may be two copies of the same file on disk until the NCO
operation successfully concludes and the temporary output file
overwrites the existing OUTPUT-FILE).  Also, note this feature
increases the execution time of the operator by approximately the time
it takes to copy the OUTPUT-FILE.  Finally, note this feature allows
the OUTPUT-FILE to be the same as the INPUT-FILE without any danger of
"overlap".

   Other safeguards exist to protect the user from inadvertently
overwriting data.  If the OUTPUT-FILE specified for a command is a
pre-existing file, then the operator will prompt the user whether to
overwrite (erase) the existing OUTPUT-FILE, attempt to append to it, or
abort the operation.  However, in processing large amounts of data, too
many interactive questions slows productivity.  Therefore NCO also
implements two ways to override its own safety features, the `-O' and
`-A' switches.  Specifying `-O' tells the operator to overwrite any
existing OUTPUT-FILE without prompting the user interactively.
Specifying `-A' tells the operator to attempt to append to any existing
OUTPUT-FILE without prompting the user interactively.  These switches
are useful in batch environments because they suppress interactive
keyboard input.

   ---------- Footnotes ----------

   (1) The `ncrename' operator is an exception to this rule.  *Note
ncrename netCDF Renamer::.


File: nco.info,  Node: Appending Variables,  Next: Simple Arithmetic and Interpolation,  Prev: Temporary Output Files,  Up: Strategies

2.4 Appending Variables
=======================

Adding variables from one file to another is often desirable.  This is
referred to as "appending", although some prefer the terminology
"merging" (1) or "pasting".  Appending is often confused with what NCO
calls "concatenation".  In NCO, concatenation refers to splicing a
variable along the record dimension.  The length along the record
dimension of the output is the sum of the lengths of the input files.
Appending, on the other hand, refers to copying a variable from one file
to another file which may or may not already contain the variable (2).
NCO can append or concatenate just one variable, or all the variables
in a file at the same time.

   In this sense, `ncks' can append variables from one file to another
file.  This capability is invoked by naming two files on the command
line, INPUT-FILE and OUTPUT-FILE.  When OUTPUT-FILE already exists, the
user is prompted whether to "overwrite", "append/replace", or "exit"
from the command.  Selecting "overwrite" tells the operator to erase
the existing OUTPUT-FILE and replace it with the results of the
operation.  Selecting "exit" causes the operator to exit--the
OUTPUT-FILE will not be touched in this case.  Selecting
"append/replace" causes the operator to attempt to place the results of
the operation in the existing OUTPUT-FILE, *Note ncks netCDF Kitchen
Sink::.

   The simplest way to create the union of two files is
     ncks -A fl_1.nc fl_2.nc
   This puts the contents of `fl_1.nc' into `fl_2.nc'.  The `-A' is
optional.  On output, `fl_2.nc' is the union of the input files,
regardless of whether they share dimensions and variables, or are
completely disjoint.  The append fails if the input files have
differently named record dimensions (since netCDF supports only one),
or have dimensions of the same name but different sizes.

   ---------- Footnotes ----------

   (1) The terminology "merging" is reserved for an (unwritten)
operator which replaces hyperslabs of a variable in one file with
hyperslabs of the same variable from another file

   (2) Yes, the terminology is confusing.  By all means mail me if you
think of a better nomenclature.  Should NCO use "paste" instead of
"append"?


File: nco.info,  Node: Simple Arithmetic and Interpolation,  Next: Averaging vs. Concatenating,  Prev: Appending Variables,  Up: Strategies

2.5 Simple Arithmetic and Interpolation
=======================================

Users comfortable with NCO semantics may find it easier to perform some
simple mathematical operations in NCO rather than higher level
languages.  `ncbo' (*note ncbo netCDF Binary Operator::) does file
addition, subtraction, multiplication, division, and broadcasting.
`ncflint' (*note ncflint netCDF File Interpolator::) does file
addition, subtraction, multiplication and interpolation.  Sequences of
these commands can accomplish simple but powerful operations from the
command line.


File: nco.info,  Node: Averaging vs. Concatenating,  Next: Large Numbers of Files,  Prev: Simple Arithmetic and Interpolation,  Up: Strategies

2.6 Averagers vs. Concatenators
===============================

The most frequently used operators of NCO are probably the averagers
and concatenators.  Because there are so many permutations of averaging
(e.g., across files, within a file, over the record dimension, over
other dimensions, with or without weights and masks) and of
concatenating (across files, along the record dimension, along other
dimensions), there are currently no fewer than five operators which
tackle these two purposes: `ncra', `ncea', `ncwa', `ncrcat', and
`ncecat'.  These operators do share many capabilities (1), but each has
its unique specialty.  Two of these operators, `ncrcat' and `ncecat',
are for concatenating hyperslabs across files.  The other two
operators, `ncra' and `ncea', are for averaging hyperslabs across files
(2).  First, let's describe the concatenators, then the averagers.

* Menu:

* Concatenation::
* Averaging::
* Interpolating::

   ---------- Footnotes ----------

   (1) Currently `ncea' and `ncrcat' are symbolically linked to the
`ncra' executable, which behaves slightly differently based on its
invocation name (i.e., `argv[0]').  These three operators share the
same source code, but merely have different inner loops.

   (2) The third averaging operator, `ncwa', is the most sophisticated
averager in NCO.  However, `ncwa' is in a different class than `ncra'
and `ncea' because it can only operate on a single file per invocation
(as opposed to multiple files).  On that single file, however, `ncwa'
provides a richer set of averaging options--including weighting,
masking, and broadcasting.


File: nco.info,  Node: Concatenation,  Next: Averaging,  Prev: Averaging vs. Concatenating,  Up: Averaging vs. Concatenating

2.6.1 Concatenators `ncrcat' and `ncecat'
-----------------------------------------

Joining independent files together along a record dimension is called
"concatenation".  `ncrcat' is designed for concatenating record
variables, while `ncecat' is designed for concatenating fixed length
variables.  Consider five files, `85.nc', `86.nc', ... `89.nc' each
containing a year's worth of data.  Say you wish to create from them a
single file, `8589.nc' containing all the data, i.e., spanning all five
years.  If the annual files make use of the same record variable, then
`ncrcat' will do the job nicely with, e.g., `ncrcat 8?.nc 8589.nc'.
The number of records in the input files is arbitrary and can vary from
file to file.  *Note ncrcat netCDF Record Concatenator::, for a
complete description of `ncrcat'.

   However, suppose the annual files have no record variable, and thus
their data are all fixed length.  For example, the files may not be
conceptually sequential, but rather members of the same group, or
"ensemble".  Members of an ensemble may have no reason to contain a
record dimension.  `ncecat' will create a new record dimension (named
RECORD by default) with which to glue together the individual files
into the single ensemble file.  If `ncecat' is used on files which
contain an existing record dimension, that record dimension is
converted to a fixed-length dimension of the same name and a new record
dimension (named `record') is created.  Consider five realizations,
`85a.nc', `85b.nc', ... `85e.nc' of 1985 predictions from the same
climate model.  Then `ncecat 85?.nc 85_ens.nc' glues the individual
realizations together into the single file, `85_ens.nc'.  If an input
variable was dimensioned [`lat',`lon'], it will have dimensions
[`record',`lat',`lon'] in the output file.  A restriction of `ncecat'
is that the hyperslabs of the processed variables must be the same from
file to file.  Normally this means all the input files are the same
size, and contain data on different realizations of the same variables.
*Note ncecat netCDF Ensemble Concatenator::, for a complete description
of `ncecat'.

   `ncpdq' makes it possible to concatenate files along any dimension,
not just the record dimension.  First, use `ncpdq' to convert the
dimension to be concatenated (i.e., extended with data from other
files) into the record dimension.  Second, use `ncrcat' to concatenate
these files.  Finally, if desirable, use `ncpdq' to revert to the
original dimensionality.  As a concrete example, say that files
`x_01.nc', `x_02.nc', ... `x_10.nc' contain time-evolving datasets from
spatially adjacent regions.  The time and spatial coordinates are
`time' and `x', respectively.  Initially the record dimension is `time'.
Our goal is to create a single file that contains joins all the
spatially adjacent regions into one single time-evolving dataset.
     for idx in 01 02 03 04 05 06 07 08 09 10; do # Bourne Shell
       ncpdq -a x,time x_${idx}.nc foo_${idx}.nc # Make x record dimension
     done
     ncrcat foo_??.nc out.nc       # Concatenate along x
     ncpdq -a time,x out.nc out.nc # Revert to time as record dimension

   Note that `ncrcat' will not concatenate fixed-length variables,
whereas `ncecat' concatenates both fixed-length and record variables
along a new record variable.  To conserve system memory, use `ncrcat'
where possible.


File: nco.info,  Node: Averaging,  Next: Interpolating,  Prev: Concatenation,  Up: Averaging vs. Concatenating

2.6.2 Averagers `ncea', `ncra', and `ncwa'
------------------------------------------

The differences between the averagers `ncra' and `ncea' are analogous
to the differences between the concatenators.  `ncra' is designed for
averaging record variables from at least one file, while `ncea' is
designed for averaging fixed length variables from multiple files.
`ncra' performs a simple arithmetic average over the record dimension
of all the input files, with each record having an equal weight in the
average.  `ncea' performs a simple arithmetic average of all the input
files, with each file having an equal weight in the average.  Note that
`ncra' cannot average fixed-length variables, but `ncea' can average
both fixed-length and record variables.  To conserve system memory, use
`ncra' rather than `ncea' where possible (e.g., if each INPUT-FILE is
one record long).  The file output from `ncea' will have the same
dimensions (meaning dimension names as well as sizes) as the input
hyperslabs (*note ncea netCDF Ensemble Averager::, for a complete
description of `ncea').  The file output from `ncra' will have the same
dimensions as the input hyperslabs except for the record dimension,
which will have a size of 1 (*note ncra netCDF Record Averager::, for a
complete description of `ncra').


File: nco.info,  Node: Interpolating,  Prev: Averaging,  Up: Averaging vs. Concatenating

2.6.3 Interpolator `ncflint'
----------------------------

`ncflint' can interpolate data between or two files.  Since no other
operators have this ability, the description of interpolation is given
fully on the `ncflint' reference page (*note ncflint netCDF File
Interpolator::).  Note that this capability also allows `ncflint' to
linearly rescale any data in a netCDF file, e.g., to convert between
differing units.


File: nco.info,  Node: Large Numbers of Files,  Next: Large Datasets,  Prev: Averaging vs. Concatenating,  Up: Strategies

2.7 Large Numbers of Files
==========================

Occasionally one desires to digest (i.e., concatenate or average)
hundreds or thousands of input files.  Unfortunately, data archives
(e.g., NASA EOSDIS) may not name netCDF files in a format understood by
the `-n LOOP' switch (*note Specifying Input Files::) that
automagically generates arbitrary numbers of input filenames.  The `-n
LOOP' switch has the virtue of being concise, and of minimizing the
command line.  This helps keeps output file small since the command
line is stored as metadata in the `history' attribute (*note History
Attribute::).  However, the `-n LOOP' switch is useless when there is no
simple, arithmetic pattern to the input filenames (e.g., `h00001.nc',
`h00002.nc', ... `h90210.nc').  Moreover, filename globbing does not
work when the input files are too numerous or their names are too
lengthy (when strung together as a single argument) to be passed by the
calling shell to the NCO operator (1).  When this occurs, the ANSI
C-standard `argc'-`argv' method of passing arguments from the calling
shell to a C-program (i.e., an NCO operator) breaks down.  There are
(at least) three alternative methods of specifying the input filenames
to NCO in environment-limited situations.

   The recommended method for sending very large numbers (hundreds or
more, typically) of input filenames to the multi-file operators is to
pass the filenames with the UNIX "standard input" feature, aka `stdin':
     # Pipe large numbers of filenames to stdin
     /bin/ls | grep ${CASEID}_'......'.nc | ncecat -o foo.nc
   This method avoids all constraints on command line size imposed by
the operating system.  A drawback to this method is that the `history'
attribute (*note History Attribute::) does not record the name of any
input files since the names were not passed on the command line.  This
makes determining the data provenance at a later date difficult.  To
remedy this situation, multi-file operators store the number of input
files in the `nco_input_file_number' global attribute and the input
file list itself in the `nco_input_file_list' global attribute (*note
File List Attributes::).  Although this does not preserve the exact
command used to generate the file, it does retains all the information
required to reconstruct the command and determine the data provenance.

   A second option is to use the UNIX `xargs' command.  This simple
example selects as input to `xargs' all the filenames in the current
directory that match a given pattern.  For illustration, consider a
user trying to average millions of files which each have a six
character filename.  If the shell buffer can not hold the results of
the corresponding globbing operator, `??????.nc', then the filename
globbing technique will fail.  Instead we express the filename pattern
as an extended regular expression, `......\.nc' (*note Subsetting
Variables::).  We use `grep' to filter the directory listing for this
pattern and to pipe the results to `xargs' which, in turn, passes the
matching filenames to an NCO multi-file operator, e.g., `ncecat'.
     # Use xargs to transfer filenames on the command line
     /bin/ls | grep ${CASEID}_'......'.nc | xargs -x ncecat -o foo.nc
   The single quotes protect the only sensitive parts of the extended
regular expression (the `grep' argument), and allow shell interpolation
(the `${CASEID}' variable substitution) to proceed unhindered on the
rest of the command.  `xargs' uses the UNIX pipe feature to append the
suitably filtered input file list to the end of the `ncecat' command
options.  The `-o foo.nc' switch ensures that the input files supplied
by `xargs' are not confused with the output file name.  `xargs' does,
unfortunately, have its own limit (usually about 20,000 characters) on
the size of command lines it can pass.  Give `xargs' the `-x' switch to
ensure it dies if it reaches this internal limit.  When this occurs,
use either the `stdin' method above, or the symbolic link presented
next.

   Even when its internal limits have not been reached, the `xargs'
technique may not be sophisticated enough to handle all situations.  A
full scripting language like Perl can handle any level of complexity of
filtering input filenames, and any number of filenames.  The technique
of last resort is to write a script that creates symbolic links between
the irregular input filenames and a set of regular, arithmetic
filenames that the `-n LOOP' switch understands.  For example, the
following Perl script a monotonically enumerated symbolic link to up to
one million `.nc' files in a directory.  If there are 999,999 netCDF
files present, the links are named `000001.nc' to `999999.nc': 
     # Create enumerated symbolic links
     /bin/ls | grep \.nc | perl -e \
     '$idx=1;while(<STDIN>){chop;symlink $_,sprintf("%06d.nc",$idx++);}'
     ncecat -n 999999,6,1 000001.nc foo.nc
     # Remove symbolic links when finished
     /bin/rm ??????.nc
   The `-n LOOP' option tells the NCO operator to automatically
generate the filnames of the symbolic links.  This circumvents any OS
and shell limits on command line size.  The symbolic links are easily
removed once NCO is finished.  One drawback to this method is that the
`history' attribute (*note History Attribute::) retains the filename
list of the symbolic links, rather than the data files themselves.
This makes it difficult to determine the data provenance at a later
date.

   ---------- Footnotes ----------

   (1) The exact length which exceeds the operating system internal
limit for command line lengths varies from OS to OS and from shell to
shell.  GNU `bash' may not have any arbitrary fixed limits to the size
of command line arguments.  Many OSs cannot handle command line
arguments (including results of file globbing) exceeding 4096
characters.


File: nco.info,  Node: Large Datasets,  Next: Memory Requirements,  Prev: Large Numbers of Files,  Up: Strategies

2.8 Large Datasets
==================

"Large datasets" are those files that are comparable in size to the
amount of random access memory (RAM) in your computer.  Many users of
NCO work with files larger than 100 MB.  Files this large not only push
the current edge of storage technology, they present special problems
for programs which attempt to access the entire file at once, such as
`ncea' and `ncecat'.  If you work with a 300 MB files on a machine with
only 32 MB of memory then you will need large amounts of swap space
(virtual memory on disk) and NCO will work slowly, or even fail.  There
is no easy solution for this.  The best strategy is to work on a
machine with sufficient amounts of memory and swap space.  Since about
2004, many users have begun to produce or analyze files exceeding 2 GB
in size.  These users should familiarize themselves with NCO's Large
File Support (LFS) capabilities (*note Large File Support::).  The next
section will increase your familiarity with NCO's memory requirements.
With this knowledge you may re-design your data reduction approach to
divide the problem into pieces solvable in memory-limited situations.

   If your local machine has problems working with large files, try
running NCO from a more powerful machine, such as a network server.
Certain machine architectures, e.g., Cray UNICOS, have special commands
which allow one to increase the amount of interactive memory.  On Cray
systems, try to increase the available memory with the `ilimit' command.  If
you get a memory-related core dump (e.g., `Error exit (core dumped)')
on a GNU/Linux system, try increasing the process-available memory with
`ulimit'.

   The speed of the NCO operators also depends on file size.  When
processing large files the operators may appear to hang, or do nothing,
for large periods of time.  In order to see what the operator is
actually doing, it is useful to activate a more verbose output mode.
This is accomplished by supplying a number greater than 0 to the `-D
DEBUG-LEVEL' (or `--debug-level', or `--dbg_lvl') switch.  When the
DEBUG-LEVEL is nonzero, the operators report their current status to
the terminal through the STDERR facility.  Using `-D' does not slow the
operators down.  Choose a DEBUG-LEVEL between 1 and 3 for most
situations, e.g., `ncea -D 2 85.nc 86.nc 8586.nc'.  A full description
of how to estimate the actual amount of memory the multi-file NCO
operators consume is given in *note Memory Requirements::.


File: nco.info,  Node: Memory Requirements,  Next: Performance,  Prev: Large Datasets,  Up: Strategies

2.9 Memory Requirements
=======================

Many people use NCO on gargantuan files which dwarf the memory
available (free RAM plus swap space) even on today's powerful machines.
These users want NCO to consume the least memory possible so that their
scripts do not have to tediously cut files into smaller pieces that fit
into memory.  We commend these greedy users for pushing NCO to its
limits!

   This section describes the memory NCO requires during operation.
The required memory is based on the underlying algorithms.  The
description below is the memory usage per thread.  Users with shared
memory machines may use the threaded NCO operators (*note OpenMP
Threading::).  The peak and sustained memory usage will scale
accordingly, i.e., by the number of threads.  Memory consumption
patterns of all operators are similar, with the exception of `ncap2'.

* Menu:

* Single and Multi-file Operators::
* Memory for ncap2::


File: nco.info,  Node: Single and Multi-file Operators,  Next: Memory for ncap2,  Prev: Memory Requirements,  Up: Memory Requirements

2.9.1 Single and Multi-file Operators
-------------------------------------

The multi-file operators currently comprise the record operators,
`ncra' and `ncrcat', and the ensemble operators, `ncea' and `ncecat'.
The record operators require _much less_ memory than the ensemble
operators.  This is because the record operators operate on one single
record (i.e., time-slice) at a time, wherease the ensemble operators
retrieve the entire variable into memory.  Let MS be the peak sustained
memory demand of an operator, FT be the memory required to store the
entire contents of all the variables to be processed in an input file,
FR be the memory required to store the entire contents of a single
record of each of the variables to be processed in an input file, VR be
the memory required to store a single record of the largest record
variable to be processed in an input file, VT be the memory required to
store the largest variable to be processed in an input file, VI be the
memory required to store the largest variable which is not processed,
but is copied from the initial file to the output file.  All operators
require MI = VI during the initial copying of variables from the first
input file to the output file.  This is the _initial_ (and transient)
memory demand.  The _sustained_ memory demand is that memory required
by the operators during the processing (i.e., averaging, concatenation)
phase which lasts until all the input files have been processed.  The
operators have the following memory requirements: `ncrcat' requires MS
<= VR.  `ncecat' requires MS <= VT.  `ncra' requires MS = 2FR + VR.
`ncea' requires MS = 2FT + VT.  `ncbo' requires MS <= 3VT (both input
variables and the output variable).  `ncflint' requires MS <= 3VT (both
input variables and the output variable).  `ncpdq' requires MS <= 2VT
(one input variable and the output variable).  `ncwa' requires MS <=
8VT (see below).  Note that only variables that are processed, e.g.,
averaged, concatenated, or differenced, contribute to MS.  Variables
which do not appear in the output file (*note Subsetting Variables::)
are never read and contribute nothing to the memory requirements.

   `ncwa' consumes between two and seven times the memory of a variable
in order to process it.  Peak consumption occurs when storing
simultaneously in memory one input variable, one tally array, one input
weight, one conformed/working weight, one weight tally, one input mask,
one conformed/working mask, and one output variable.  When invoked, the
weighting and masking features contribute up to three-sevenths and
two-sevenths of these requirements apiece.  If weights and masks are
_not_ specified (i.e., no `-w' or `-a' options) then `ncwa'
requirements drop to MS <= 3VT (one input variable, one tally array,
and the output variable).

   The above memory requirements must be multiplied by the number of
threads THR_NBR (*note OpenMP Threading::).  If this causes problems
then reduce (with `-t THR_NBR') the number of threads.


File: nco.info,  Node: Memory for ncap2,  Prev: Single and Multi-file Operators,  Up: Memory Requirements

2.9.2 Memory for `ncap2'
------------------------

`ncap2' has unique memory requirements due its ability to process
arbitrarily long scripts of any complexity.  All scripts acceptable to
`ncap2' are ultimately processed as a sequence of binary or unary
operations.  `ncap2' requires MS <= 2VT under most conditions.  An
exception to this is when left hand casting (*note Left hand casting::)
is used to stretch the size of derived variables beyond the size of any
input variables.  Let VC be the memory required to store the largest
variable defined by left hand casting.  In this case, MS <= 2VC.

   `ncap2' scripts are complete dynamic and may be of arbitrary length.
A script that contains many thousands of operations, may uncover a slow
memory leak even though each single operation consumes little
additional memory.  Memory leaks are usually identifiable by their
memory usage signature.  Leaks cause peak memory usage to increase
monotonically with time regardless of script complexity.  Slow leaks
are very difficult to find.  Sometimes a `malloc()' (or `new[]')
failure is the only noticeable clue to their existance.  If you have
good reasons to believe that a memory allocation failure is ultimately
due to an NCO memory leak (rather than inadequate RAM on your system),
then we would be very interested in receiving a detailed bug report.


File: nco.info,  Node: Performance,  Prev: Memory Requirements,  Up: Strategies

2.10 Performance
================

An overview of NCO capabilities as of about 2006 is in Zender, C. S.
(2008), "Analysis of Self-describing Gridded Geoscience Data with
netCDF Operators (NCO)", Environ. Modell. Softw.,
doi:10.1016/j.envsoft.2008.03.004.  This paper is also available at
`http://dust.ess.uci.edu/ppr/ppr_Zen08_ems.pdf'.

   NCO performance and scaling for arithmetic operations is described in
Zender, C. S., and H. J. Mangalam (2007), "Scaling Properties of Common
Statistical Operators for Gridded Datasets", Int. J. High Perform.
Comput. Appl., 21(4), 485-498, doi:10.1177/1094342007083802.  This
paper is also available at
`http://dust.ess.uci.edu/ppr/ppr_ZeM07_ijhpca.pdf'.

   It is helpful to be aware of the aspects of NCO design that can
limit its performance:
  1. No data buffering is performed during `nc_get_var' and
     `nc_put_var' operations.  Hyperslabs too large too hold in core
     memory will suffer substantial performance penalties because of
     this.

  2. Since coordinate variables are assumed to be monotonic, the search
     for bracketing the user-specified limits should employ a quicker
     algorithm, like bisection, than the two-sided incremental search
     currently implemented.

  3. C_FORMAT, FORTRAN_FORMAT, SIGNEDNESS, SCALE_FORMAT and ADD_OFFSET
     attributes are ignored by `ncks' when printing variables to screen.

  4. In the late 1990s it was discovered that some random access
     operations on large files on certain architectures (e.g., UNICOS)
     were much slower with NCO than with similar operations performed
     using languages that bypass the netCDF interface (e.g., Yorick).
     This may have been a penalty of unnecessary byte-swapping in the
     netCDF interface.  It is unclear whether such problems exist in
     present day (2007) netCDF/NCO environments, where unnecessary
     byte-swapping has been reduced or eliminated.


File: nco.info,  Node: Common features,  Next: Operator Reference Manual,  Prev: Strategies,  Up: Top

3 NCO Features
**************

Many features have been implemented in more than one operator and are
described here for brevity.  The description of each feature is
preceded by a box listing the operators for which the feature is
implemented.  Command line switches for a given feature are consistent
across all operators wherever possible.  If no "key switches" are
listed for a feature, then that particular feature is automatic and
cannot be controlled by the user.

* Menu:

* Internationalization::
* Metadata Optimization::
* OpenMP Threading::
* Command Line Options::
* Specifying Input Files::
* Specifying Output Files::
* Remote storage::
* Retaining Retrieved Files::
* Selecting Output File Format::
* Large File Support::
* Subsetting Variables::
* Subsetting Coordinate Variables::
* C and Fortran Index Conventions::
* Hyperslabs::
* Stride::
* Multislabs::
* Wrapped Coordinates::
* Auxiliary Coordinates::
* UDUnits Support::
* Rebasing Time Coordinate::
* Missing Values::
* Chunking::
* Deflation::
* Packed data::
* Operation Types::
* Type Conversion::
* Batch Mode::
* History Attribute::
* File List Attributes::
* CF Conventions::
* ARM Conventions::
* Operator Version::


File: nco.info,  Node: Internationalization,  Next: Metadata Optimization,  Prev: Common features,  Up: Common features

3.1 Internationalization
========================

Availability: All operators
NCO support for "internationalization" of textual input and output
(e.g., Warning messages) is nascent.  We hope to produce foreign
language string catalogues in 2004.


File: nco.info,  Node: Metadata Optimization,  Next: OpenMP Threading,  Prev: Internationalization,  Up: Common features

3.2 Metadata Optimization
=========================

Availability: `ncatted', `ncks', `ncrename'
Short options: None
Long options: `--hdr_pad', `--header_pad'
NCO supports padding headers to improve the speed of future metadata
operations.  Use the `--hdr_pad' and `--header_pad' switches to request
that HDR_PAD bytes be inserted into the metadata section of the output
file.  Future metadata expansions will not incur the performance
penalty of copying the entire output file unless the expansion exceeds
the amount of header padding exceeded.  This can be beneficial when it
is known that some metadata will be added at a future date.

   This optimization exploits the netCDF library `nc__enddef()'
function, which behaves differently with different versions of netCDF.
It will improve speed of future metadata expansion with `CLASSIC' and
`64bit' netCDF files, but not necessarily with `NETCDF4' files, i.e.,
those created by the netCDF interface to the HDF5 library (*note
Selecting Output File Format::).


File: nco.info,  Node: OpenMP Threading,  Next: Command Line Options,  Prev: Metadata Optimization,  Up: Common features

3.3 OpenMP Threading
====================

Availability: `ncap2', `ncbo', `ncea', `ncecat', `ncflint', `ncpdq',
`ncra', `ncrcat', `ncwa'
Short options: `-t'
Long options: `--thr_nbr', `--threads', `--omp_num_threads'
NCO supports shared memory parallelism (SMP) when compiled with an
OpenMP-enabled compiler.  Threads requests and allocations occur in two
stages.  First, users may request a specific number of threads THR_NBR
with the `-t' switch (or its long option equivalents, `--thr_nbr',
`--threads', and `--omp_num_threads').  If not user-specified, OpenMP
obtains THR_NBR from the `OMP_NUM_THREADS' environment variable, if
present, or from the OS, if not.

   NCO may modify THR_NBR according to its own internal settings before
it requests any threads from the system.  Certain operators contain
hard-code limits to the number of threads they request.  We base these
limits on our experience and common sense, and to reduce potentially
wasteful system usage by inexperienced users.  For example, `ncrcat' is
extremely I/O-intensive so we restrict THR_NBR <= 2 for `ncrcat'.  This
is based on the notion that the best performance that can be expected
from an operator which does no arithmetic is to have one thread reading
and one thread writing simultaneously.  In the future (perhaps with
netCDF4), we hope to demonstrate significant threading improvements
with operators like `ncrcat' by performing multiple simultaneous writes.

   Compute-intensive operators (`ncap', `ncwa' and `ncpdq') benefit
most from threading.  The greatest increases in throughput due to
threading occur on large datasets where each thread performs millions,
at least, of floating point operations.  Otherwise, the system overhead
of setting up threads probably outweighs the speed enhancements due to
SMP parallelism.  However, we have not yet demonstrated that the SMP
parallelism scales well beyond four threads for these operators.  Hence
we restrict THR_NBR <= 4 for all operators.  We encourage users to play
with these limits (edit file `nco_omp.c') and send us their feedback.

   Once the initial THR_NBR has been modified for any operator-specific
limits, NCO requests the system to allocate a team of THR_NBR threads
for the body of the code.  The operating system then decides how many
threads to allocate based on this request.  Users may keep track of
this information by running the operator with DBG_LVL > 0.

   By default, threaded operators attach one global attribute,
`nco_openmp_thread_number', to any file they create or modify.  This
attribute contains the number of threads the operator used to process
the input files.  This information helps to verify that the answers
with threaded and non-threaded operators are equal to within machine
precision.  This information is also useful for benchmarking.


File: nco.info,  Node: Command Line Options,  Next: Specifying Input Files,  Prev: OpenMP Threading,  Up: Common features

3.4 Command Line Options
========================

Availability: All operators
NCO achieves flexibility by using "command line options".  These
options are implemented in all traditional UNIX commands as single
letter "switches", e.g., `ls -l'.  For many years NCO used only single
letter option names.  In late 2002, we implemented GNU/POSIX extended
or long option names for all options.  This was done in a backward
compatible way such that the full functionality of NCO is still
available through the familiar single letter options.  In the future,
however, some features of NCO may require the use of long options,
simply because we have nearly run out of single letter options.  More
importantly, mnemonics for single letter options are often
non-intuitive so that long options provide a more natural way of
expressing intent.

   Extended options, also called long options, are implemented using the
system-supplied `getopt.h' header file, if possible.  This provides the
`getopt_long' function to NCO (1).

   The syntax of "short options" (single letter options) is `-KEY
VALUE' (dash-key-space-value).  Here, KEY is the single letter option
name, e.g., `-D 2'.

   The syntax of "long options" (multi-letter options) is `--LONG_NAME
VALUE' (dash-dash-key-space-value), e.g., `--dbg_lvl 2' or
`--LONG_NAME=VALUE' (dash-dash-key-equal-value), e.g., `--dbg_lvl=2'.
Thus the following are all valid for the `-D' (short version) or
`--dbg_lvl' (long version) command line option.
     ncks -D 3 in.nc        # Short option
     ncks --dbg_lvl=3 in.nc # Long option, preferred form
     ncks --dbg_lvl 3 in.nc # Long option, alternate form
   The last example is preferred for two reasons.  First, `--dbg_lvl'
is more specific and less ambiguous than `-D'.  The long option form
makes scripts more self documenting and less error prone.  Often long
options are named after the source code variable whose value they carry.
Second, the equals sign `=' joins the key (i.e., LONG_NAME) to the
value in an uninterruptible text block.  Experience shows that users
are less likely to mis-parse commands when restricted to this form.

   GNU implements a superset of the POSIX standard which allows any
unambiguous truncation of a valid option to be used.
     ncks -D 3 in.nc        # Short option
     ncks --dbg_lvl=3 in.nc # Long option, full form
     ncks --dbg=3 in.nc     # Long option, unambiguous truncation
     ncks --db=3 in.nc      # Long option, unambiguous truncation
     ncks --d=3 in.nc       # Long option, ambiguous truncation
   The first four examples are equivalent and will work as expected.
The final example will exit with an error since `ncks' cannot
disambiguate whether `--d' is intended as a truncation of `--dbg_lvl',
of `--dimension', or of some other long option.

   NCO provides many long options for common switches.  For example,
the debugging level may be set in all operators with any of the
switches `-D', `--debug-level', or `--dbg_lvl'.  This flexibility
allows users to choose their favorite mnemonic.  For some, it will be
`--debug' (an unambiguous truncation of `--debug-level', and other will
prefer `--dbg'.  Interactive users usually prefer the minimal amount of
typing, i.e., `-D'.  We recommend that scripts which are re-usable
employ some form of the long options for future maintainability.

   This manual generally uses the short option syntax.  This is for
historical reasons and to conserve space.  The remainder of this manual
specifies the full LONG_NAME of each option.  Users are expected to
pick the unambiguous truncation of each option name that most suits
their taste.

   ---------- Footnotes ----------

   (1) If a `getopt_long' function cannot be found on the system, NCO
will use the `getopt_long' from the `my_getopt' package by Benjamin
Sittler <bsittler@iname.com>.  This is BSD-licensed software available
from `http://www.geocities.com/ResearchTriangle/Node/9405/#my_getopt'.


File: nco.info,  Node: Specifying Input Files,  Next: Specifying Output Files,  Prev: Command Line Options,  Up: Common features

3.5 Specifying Input Files
==========================

Availability (`-n'): `ncea', `ncecat', `ncra', `ncrcat'
Availability (`-p'): All operators
Short options: `-n', `-p'
Long options: `--nintap', `--pth', `--path'
It is important that users be able to specify multiple input files
without typing every filename in full, often a tedious task even by
graduate student standards.  There are four different ways of
specifying input files to NCO: explicitly typing each, using UNIX shell
wildcards, and using the NCO `-n' and `-p' switches (or their long
option equivalents, `--nintap' or `--pth' and `--path', respectively).
To illustrate these methods, consider the simple problem of using
`ncra' to average five input files, `85.nc', `86.nc', ... `89.nc', and
store the results in `8589.nc'.  Here are the four methods in order.
They produce identical answers.
     ncra 85.nc 86.nc 87.nc 88.nc 89.nc 8589.nc
     ncra 8[56789].nc 8589.nc
     ncra -p INPUT-PATH 85.nc 86.nc 87.nc 88.nc 89.nc 8589.nc
     ncra -n 5,2,1 85.nc 8589.nc
   The first method (explicitly specifying all filenames) works by brute
force.  The second method relies on the operating system shell to "glob"
(expand) the "regular expression" `8[56789].nc'.  The shell passes
valid filenames which match the expansion to `ncra'.  The third method
uses the `-p INPUT-PATH' argument to specify the directory where all
the input files reside.  NCO prepends INPUT-PATH (e.g.,
`/data/usrname/model') to all INPUT-FILES (but not to OUTPUT-FILE).
Thus, using `-p', the path to any number of input files need only be
specified once.  Note INPUT-PATH need not end with `/'; the `/' is
automatically generated if necessary.

   The last method passes (with `-n') syntax concisely describing the
entire set of filenames (1).  This option is only available with the
"multi-file operators": `ncra', `ncrcat', `ncea', and `ncecat'.  By
definition, multi-file operators are able to process an arbitrary
number of INPUT-FILES.  This option is very useful for abbreviating
lists of filenames representable as
ALPHANUMERIC_PREFIX+NUMERIC_SUFFIX+`.'+FILETYPE where
ALPHANUMERIC_PREFIX is a string of arbitrary length and composition,
NUMERIC_SUFFIX is a fixed width field of digits, and FILETYPE is a
standard filetype indicator.  For example, in the file `ccm3_h0001.nc',
we have ALPHANUMERIC_PREFIX = `ccm3_h', NUMERIC_SUFFIX = `0001', and
FILETYPE = `nc'.

   NCO is able to decode lists of such filenames encoded using the `-n'
option.  The simpler (3-argument) `-n' usage takes the form `-n
FILE_NUMBER,DIGIT_NUMBER,NUMERIC_INCREMENT' where FILE_NUMBER is the
number of files, DIGIT_NUMBER is the fixed number of numeric digits
comprising the NUMERIC_SUFFIX, and NUMERIC_INCREMENT is the constant,
integer-valued difference between the NUMERIC_SUFFIX of any two
consecutive files.  The value of ALPHANUMERIC_PREFIX is taken from the
input file, which serves as a template for decoding the filenames.  In
the example above, the encoding `-n 5,2,1' along with the input file
name `85.nc' tells NCO to construct five (5) filenames identical to the
template `85.nc' except that the final two (2) digits are a numeric
suffix to be incremented by one (1) for each successive file.
Currently FILETYPE may be either be empty, `nc', `cdf', `hdf', or `hd5'.
If present, these FILETYPE suffixes (and the preceding `.') are ignored
by NCO as it uses the `-n' arguments to locate, evaluate, and compute
the NUMERIC_SUFFIX component of filenames.

   Recently the `-n' option has been extended to allow convenient
specification of filenames with "circular" characteristics.  This means
it is now possible for NCO to automatically generate filenames which
increment regularly until a specified maximum value, and then wrap back
to begin again at a specified minimum value.  The corresponding `-n'
usage becomes more complex, taking one or two additional arguments for
a total of four or five, respectively: `-n
FILE_NUMBER,DIGIT_NUMBER,NUMERIC_INCREMENT[,NUMERIC_MAX[,NUMERIC_MIN]]'
where NUMERIC_MAX, if present, is the maximum integer-value of
NUMERIC_SUFFIX and NUMERIC_MIN, if present, is the minimum
integer-value of NUMERIC_SUFFIX.  Consider, for example, the problem of
specifying non-consecutive input files where the filename suffixes end
with the month index.  In climate modeling it is common to create
summertime and wintertime averages which contain the averages of the
months June-July-August, and December-January-February, respectively:
     ncra -n 3,2,1 85_06.nc 85_0608.nc
     ncra -n 3,2,1,12 85_12.nc 85_1202.nc
     ncra -n 3,2,1,12,1 85_12.nc 85_1202.nc
   The first example shows that three arguments to the `-n' option
suffice to specify consecutive months (`06, 07, 08') which do not
"wrap" back to a minimum value.  The second example shows how to use
the optional fourth and fifth elements of the `-n' option to specify a
wrap value to NCO.  The fourth argument to `-n', if present, specifies
the maximum integer value of NUMERIC_SUFFIX.  In this case the maximum
value is 12, and will be formatted as `12' in the filename string.  The
fifth argument to `-n', if present, specifies the minimum integer value
of NUMERIC_SUFFIX.  The default minimum filename suffix is 1, which is
formatted as `01' in this case.  Thus the second and third examples
have the same effect, that is, they automatically generate, in order,
the filenames `85_12.nc', `85_01.nc', and `85_02.nc' as input to NCO.

   ---------- Footnotes ----------

   (1) The `-n' option is a backward compatible superset of the
`NINTAP' option from the NCAR CCM Processor.


File: nco.info,  Node: Specifying Output Files,  Next: Remote storage,  Prev: Specifying Input Files,  Up: Common features

3.6 Specifying Output Files
===========================

Availability: All operators
Short options: `-o'
Long options: `--fl_out', `--output'
NCO commands produce no more than one output file, FL_OUT.
Traditionally, users specify FL_OUT as the final argument to the
operator, following all input file names.  This is the "positional
argument" method of specifying input and ouput file names.  The
positional argument method works well in most applications.  NCO also
supports specifying FL_OUT using the command line switch argument
method, `-o FL_OUT'.

   Specifying FL_OUT with a switch, rather than as a positional
argument, allows FL_OUT to precede input files in the argument list.  This
is particularly useful with multi-file operators for three reasons.
Multi-file operators may be invoked with hundreds (or more) filenames.
Visual or automatic location of FL_OUT in such a list is difficult when
the only syntactic distinction between input and output files is their
position.  Second, specification of a long list of input files may be
difficult (*note Large Numbers of Files::).  Making the input file list
the final argument to an operator facilitates using `xargs' for this
purpose.  Some alternatives to `xargs' are very ugly and undesirable.
Finally, many users are more comfortable specifying output files with
`-o FL_OUT' near the beginning of an argument list.  Compilers and
linkers are usually invoked this way.

   Users should specify FL_OUT using either but not both methods.  If
FL_OUT is specified twice (once with the switch and once as the last
positional argument), then the positional argument takes precedence.


File: nco.info,  Node: Remote storage,  Next: Retaining Retrieved Files,  Prev: Specifying Output Files,  Up: Common features

3.7 Accessing Remote Files
==========================

Availability: All operators
Short options: `-p', `-l'
Long options: `--pth', `--path', `--lcl', `--local'
All NCO operators can retrieve files from remote sites as well as from
the local file system.  A remote site can be an anonymous FTP server, a
machine on which the user has `rcp', `scp', or `sftp' privileges, or
NCAR's Mass Storage System (MSS), or an OPeNDAP server.  Examples of
each are given below, following a brief description of the particular
access protocol.

   To access a file via an anonymous FTP server, supply the remote
file's URL.  FTP is an intrinsically insecure protocol because it
transfers passwords in plain text format.  Users should access sites
using anonymous FTP when possible.  Some FTP servers require a
login/password combination for a valid user account.  NCO allows these
transactions so long as the required information is stored in the
`.netrc' file.  Usually this information is the remote machine name,
login, and password, in plain text, separated by those very keywords,
e.g.,
     machine dust.ess.uci.edu login zender password bushlied
   Eschew using valuable passwords for FTP transactions, since `.netrc'
passwords are potentially exposed to eavesdropping software (1).

   SFTP, i.e., secure FTP, uses SSH-based security protocols that solve
the security issues associated with plain FTP.  NCO supports SFTP
protocol access to files specified with a homebrew syntax of the form
     sftp://machine.domain.tld:/path/to/filename
   Note the second colon following the top-level-domain (tld).  This
syntax is a hybrid between an FTP URL and a standard remote file syntax.

   To access a file using `rcp' or `scp', specify the Internet address
of the remote file.  Of course in this case you must have `rcp' or `scp'
privileges which allow transparent (no password entry required) access
to the remote machine.  This means that `~/.rhosts' or
`~/ssh/authorized_keys' must be set accordingly on both local and
remote machines.

   To access a file on NCAR's MSS, specify the full MSS pathname of the
remote file.  NCO will attempt to detect whether the local machine has
direct (synchronous) MSS access.  In this case, NCO attempts to use the
NCAR `msrcp' command (2), or, failing that, `/usr/local/bin/msread'.
Otherwise NCO attempts to retrieve the MSS file through the
(asynchronous) Masnet Interface Gateway System (MIGS) using the `nrnet'
command.

   The following examples show how one might analyze files stored on
remote systems.
     ncks -l . ftp://dust.ess.uci.edu/pub/zender/nco/in.nc
     ncks -l . sftp://dust.ess.uci.edu:/home/ftp/pub/zender/nco/in.nc
     ncks -l . dust.ess.uci.edu:/home/zender/nco/data/in.nc
     ncks -l . /ZENDER/nco/in.nc
     ncks -l . mss:/ZENDER/nco/in.nc
     ncks -l . http://dust.ess.uci.edu/cgi-bin/dods/nph-dods/dodsdata/in.nc
   The first example works verbatim if your system is connected to the
Internet and is not behind a firewall.  The second example works if you
have `sftp' access to the machine `dust.ess.uci.edu'.  The third
example works if you have `rcp' or `scp' access to the machine
`dust.ess.uci.edu'.  The fourth and fifth examples work on NCAR
computers with local access to the `msrcp', `msread', or `nrnet'
commands.  The sixth command works if your local version of NCO is
OPeNDAP-enabled (this is fully described in *note OPeNDAP::).  The
above commands can be rewritten using the `-p INPUT-PATH' option as
follows: 
     ncks -p ftp://dust.ess.uci.edu/pub/zender/nco -l . in.nc
     ncks -p sftp://dust.ess.uci.edu:/home/ftp/pub/zender/nco -l . in.nc
     ncks -p dust.ess.uci.edu:/home/zender/nco -l . in.nc
     ncks -p /ZENDER/nco -l . in.nc
     ncks -p mss:/ZENDER/nco -l . in.nc
     ncks -p http://dust.ess.uci.edu/cgi-bin/dods/nph-dods/dodsdata \
          -l . in.nc
   Using `-p' is recommended because it clearly separates the
INPUT-PATH from the filename itself, sometimes called the "stub".  When
INPUT-PATH is not explicitly specified using `-p', NCO internally
generates an INPUT-PATH from the first input filename.  The
automatically generated INPUT-PATH is constructed by stripping the
input filename of everything following the final `/' character (i.e.,
removing the stub).  The `-l OUTPUT-PATH' option tells NCO where to
store the remotely retrieved file and the output file.  Often the path
to a remotely retrieved file is quite different than the path on the
local machine where you would like to store the file.  If `-l' is not
specified then NCO internally generates an OUTPUT-PATH by simply
setting OUTPUT-PATH equal to INPUT-PATH stripped of any machine names.
If `-l' is not specified and the remote file resides on the NCAR MSS
system, then the leading character of INPUT-PATH, `/', is also stripped
from OUTPUT-PATH.  Specifying OUTPUT-PATH as `-l ./' tells NCO to store
the remotely retrieved file and the output file in the current
directory.  Note that `-l .' is equivalent to `-l ./' though the latter
is recommended as it is syntactically more clear.

* Menu:

* OPeNDAP::

   ---------- Footnotes ----------

   (1) NCO does not implement command line options to specify FTP
logins and passwords because copying those data into the `history'
global attribute in the output file (done by default) poses an
unacceptable security risk.

   (2) The `msrcp' command must be in the user's path and located in
one of the following directories: `/usr/local/bin', `/usr/bin',
`/opt/local/bin', or `/usr/local/dcs/bin'.


File: nco.info,  Node: OPeNDAP,  Prev: Remote storage,  Up: Remote storage

3.7.1 OPeNDAP
-------------

The Distributed Oceanographic Data System (DODS) provides useful
replacements for common data interface libraries like netCDF.  The DODS
versions of these libraries implement network transparent access to
data via a client-server data access protocol that uses the HTTP
protocol for communication.  Although DODS-technology originated with
oceanography data, it applyies to virtually all scientific data.  In
recognition of this, the data access protocol underlying DODS (which is
what NCO cares about) has been renamed the Open-source Project for a
Network Data Access Protocol, OPeNDAP.  We use the terms DODS and
OPeNDAP interchangeably, and often write OPeNDAP/DODS for now.  In the
future we will deprecate DODS in favor of DAP or OPeNDAP, as appropriate
(1).

   NCO may be DAP-enabled by linking NCO to the OPeNDAP libraries.  This
is described in the OPeNDAP documentation and automagically implemented
in NCO build mechanisms (2).  The `./configure' mechanism automatically
enables NCO as OPeNDAP clients if it can find the required OPeNDAP
libraries (3).   in the usual locations.  The `$DODS_ROOT' environment
variable may be used to override the default OPeNDAP library location
at NCO compile-time.  Building NCO with `bld/Makefile' and the command
`make DODS=Y' adds the (non-intuitive) commands to link to the OPeNDAP
libraries installed in the `$DODS_ROOT' directory.  The file
`doc/opendap.sh' contains a generic script intended to help users
install OPeNDAP before building NCO.  The documentation at the OPeNDAP
Homepage (http://www.opendap.org) is voluminous.  Check there and on the
DODS mail lists
(http://www.unidata.ucar.edu/packages/dods/home/mailLists/).  to learn
more about the extensive capabilities of OPeNDAP (4).

   Once NCO is DAP-enabled the operators are OPeNDAP clients.  All
OPeNDAP clients have network transparent access to any files controlled
by a OPeNDAP server.  Simply specify the input file path(s) in URL
notation and all NCO operations may be performed on remote files made
accessible by a OPeNDAP server.  This command tests the basic
functionality of OPeNDAP-enabled NCO clients:
     % ncks -o ~/foo.nc -C -H -v one -l /tmp \
       -p http://dust.ess.uci.edu/cgi-bin/dods/nph-dods/dodsdata in.nc
     one = 1
     % ncks -H -v one ~/foo.nc
     one = 1
   The `one = 1' outputs confirm (first) that `ncks' correctly
retrieved data via the  OPeNDAP protocol and (second) that `ncks'
created a valid local copy of the subsetted remote file.

   The next command is a more advanced example which demonstrates the
real power of OPeNDAP-enabled NCO clients.  The `ncwa' client requests
an equatorial hyperslab from remotely stored NCEP reanalyses data of
the year 1969.  The NOAA OPeNDAP server (hopefully!) serves these data.
The local `ncwa' client then computes and stores (locally) the regional
mean surface pressure (in Pa).
     ncwa -C -a lat,lon,time -d lon,-10.,10. -d lat,-10.,10. -l /tmp -p \
     http://www.esrl.noaa.gov/psd/thredds/dodsC/Datasets/ncep.reanalysis.dailyavgs/surface \
       pres.sfc.1969.nc ~/foo.nc
   All with one command!  The data in this particular input file also
happen to be packed (*note Methods and functions::), although this is
completely transparent to the user since NCO automatically unpacks data
before attempting arithmetic.

   NCO obtains remote files from the OPeNDAP server (e.g.,
`www.cdc.noaa.gov') rather than the local machine.  Input files are
first copied to the local machine, then processed.  The OPeNDAP server
performs data access, hyperslabbing, and transfer to the local machine.  This
allows the I/O to appear to NCO as if the input files were local.  The
local machine performs all arithmetic operations.  Only the
hyperslabbed output data are transferred over the network (to the local
machine) for the number-crunching to begin.  The advantages of this are
obvious if you are examining small parts of large files stored at
remote locations.

   ---------- Footnotes ----------

   (1) DODS is being deprecated because it is ambiguous, referring both
to a protocol and to a collection of (oceanography) data.  It is
superceded by two terms.  DAP is the discipline-neutral Data Access
Protocol at the heart of DODS.  The National Virtual Ocean Data System
(NVODS) refers to the collection of oceanography data and oceanographic
extensions to DAP.  In other words, NVODS is implemented with OPeNDAP.
OPeNDAP is _also_ the open source project which maintains, develops,
and promulgates the DAP standard.  OPeNDAP and DAP really are
interchangeable.  Got it yet?

   (2) Automagic support for DODS version 3.2.x was deprecated in
December, 2003 after NCO version 2.8.4.  NCO support for OPeNDAP
versions 3.4.x commenced in December, 2003, with NCO version 2.8.5.
NCO support for OPeNDAP versions 3.5.x commenced in June, 2005, with
NCO version 3.0.1.  NCO support for OPeNDAP versions 3.6.x commenced in
June, 2006, with NCO version 3.1.3.  NCO support for OPeNDAP versions
3.7.x commenced in January, 2007, with NCO version 3.1.9.

   (3) The minimal set of libraries required to build NCO as OPeNDAP
clients are, in link order, `libnc-dap.a', `libdap.a', and `libxml2'
and `libcurl.a'.

   (4) We are most familiar with the OPeNDAP ability to enable
network-transparent data access.  OPeNDAP has many other features,
including sophisticated hyperslabbing and server-side processing via
"constraint expressions".  If you know more about this, please consider
writing a section on "OPeNDAP Capabilities of Interest to NCO Users"
for incorporation in the `NCO User's Guide'.


File: nco.info,  Node: Retaining Retrieved Files,  Next: Selecting Output File Format,  Prev: Remote storage,  Up: Common features

3.8 Retaining Retrieved Files
=============================

Availability: All operators
Short options: `-R'
Long options: `--rtn', `--retain'
In order to conserve local file system space, files retrieved from
remote locations are automatically deleted from the local file system
once they have been processed.  Many NCO operators were constructed to
work with numerous large (e.g., 200 MB) files.  Retrieval of multiple
files from remote locations is done serially.  Each file is retrieved,
processed, then deleted before the cycle repeats.  In cases where it is
useful to keep the remotely-retrieved files on the local file system
after processing, the automatic removal feature may be disabled by
specifying `-R' on the command line.

   Invoking `-R' disables the default printing behavior of `ncks'.
This allows `ncks' to retrieve remote files without automatically
trying to print them.  See *note ncks netCDF Kitchen Sink::, for more
details.

   Note that the remote retrieval features of NCO can always be used to
retrieve _any_ file, including non-netCDF files, via `SSH', anonymous
FTP, or `msrcp'.  Often this method is quicker than using a browser, or
running an FTP session from a shell window yourself.  For example, say
you want to obtain a JPEG file from a weather server.
     ncks -R -p ftp://weather.edu/pub/pix/jpeg -l . storm.jpg
   In this example, `ncks' automatically performs an anonymous FTP
login to the remote machine and retrieves the specified file.  When
`ncks' attempts to read the local copy of `storm.jpg' as a netCDF file,
it fails and exits, leaving  `storm.jpg' in the current directory.

   If your NCO is DAP-enabled (*note OPeNDAP::), then you may use NCO
to retrieve any files (including netCDF, HDF, etc.) served by an
OPeNDAP server to your local machine.  For example,
     ncks -R -l . -p \
     http://www.esrl.noaa.gov/psd/thredds/dodsC/Datasets/ncep.reanalysis.dailyavgs/surface \
       pres.sfc.1969.nc
   Note that NCO is never the preffered way to transport files from
remote machines.  For large jobs, that is best handled by FTP, SSH, or
`wget'.  It may occasionally be useful to use NCO to transfer files
when your other preferred methods are not available locally.


File: nco.info,  Node: Selecting Output File Format,  Next: Large File Support,  Prev: Retaining Retrieved Files,  Up: Common features

3.9 Selecting Output File Format
================================

Availability: `ncap2', `ncbo', `ncea', `ncecat', `ncflint', `ncks',
`ncpdq', `ncra', `ncrcat', `ncwa'
Short options: `-3', `-4'
Long options: `--3', `--4', `--64bit', `--fl_fmt', `--netcdf4'
All NCO operators support (read and write) all three (or four,
depending on how one counts) file formats supported by netCDF4.  The
default output file format for all operators is the input file format.
The operators listed under "Availability" above allow the user to
specify the output file format independent of the input file format.
These operators allow the user to convert between the various file
formats.  (The operators `ncatted' and `ncrename' do not support these
switches so they always write the output netCDF file in the same format
as the input netCDF file.)

   netCDF supports four types of files: `CLASSIC', `64BIT', `NETCDF4',
and `NETCDF4_CLASSIC', The `CLASSIC' format is the traditional 32-bit
offset written by netCDF2 and netCDF3.  As of 2005, most netCDF
datasets are in `CLASSIC' format.  The `64BIT' format was added in
Fall, 2004.

   The `NETCDF4' format uses HDF5 as the file storage layer.  The files
are (usually) created, accessed, and manipulated using the traditional
netCDF3 API (with numerous extensions).  The `NETCDF4_CLASSIC' format
refers to netCDF4 files created with the `NC_CLASSIC_MODEL' mask.  Such
files use HDF5 as the back-end storage format (unlike netCDF3), though
they incorporate only netCDF3 features.  Hence `NETCDF4_CLASSIC' files
are perfectly readable by applications which use only the netCDF3 API
and library.  NCO must be built with netCDF4 to write files in the new
`NETCDF4' and `NETCDF4_CLASSIC' formats, and to read files in the new
`NETCDF4' format.  Users are advised to use the default `CLASSIC'
format or the `NETCDF4_CLASSIC' format until netCDF4 is more widespread.
Widespread support for `NETCDF4' format files is not expected for a few
more years, 2010-2011, say.  If performance or coolness are issues,
then use `NETCDF4_CLASSIC' instead of `CLASSIC' format files.

   As mentioned above, all operators write use the input file format for
output files unless told otherwise.  Toggling the long option `--64bit'
switch (or its KEY-VALUE equivalent `--fl_fmt=64bit') produces the
netCDF3 64-bit offset format named `64BIT'.  NCO must be built with
netCDF 3.6 or higher to produce a `64BIT' file.  Using the `-4' switch
(or its long option equivalents `--4' or `--netcdf4'), or setting its
KEY-VALUE equivalent `--fl_fmt=netcdf4' produces a `NETCDF4' file
(i.e., HDF).  Casual users are advised to use the default (netCDF3)
`CLASSIC' format until netCDF 3.6 and netCDF 4.0 are more widespread.
Conversely, operators given the `-3' (or `--3') switch without
arguments will (attempt to) produce netCDF3 `CLASSIC' output, even from
netCDF4 input files.

   These examples demonstrate converting a file from any netCDF format
into any other netCDF format (subject to limits of the format):
     ncks --fl_fmt=classic in.nc foo_3c.nc # netCDF3 classic
     ncks --fl_fmt=64bit in.nc foo_364.nc # netCDF3 64bit
     ncks --fl_fmt=netcdf4_classic in.nc foo_4c.nc # netCDF4 classic
     ncks --fl_fmt=netcdf4 in.nc foo_4.nc # netCDF4
     ncks -3 in.nc foo_3c.nc # netCDF3 classic
     ncks --3 in.nc foo_3c.nc # netCDF3 classic
     ncks -4 in.nc foo_4.nc # netCDF4
     ncks --4 in.nc foo_4.nc # netCDF4
     ncks --64 in.nc foo364.nc # netCDF3 64bit
   Of course since most operators support these switches, the
"conversions" can be done at the output stage of arithmetic or metadata
processing rather than requiring a separate step.  Producing (netCDF3)
`CLASSIC' or `64BIT' files from `NETCDF4_CLASSIC' files will always
work.  However, producing netCDF3 files from `NETCDF4' files will only
work if the output files are not required to contain netCDF4-specific
features.

   Note that `NETCDF4' and `NETCDF4_CLASSIC' are the same binary format.
The latter simply causes a writing application to fail if it attempts to
write a `NETCDF4' file that cannot be completely read by the netCDF3
library.  Conversely, `NETCDF4_CLASSIC' indicates to a reading
application that all of the file contents are readable with the netCDF3
library.  As of October, 2005, NCO writes no netCDF4-specific data
structures and so always succeeds at writing `NETCDF4_CLASSIC' files.

   There are at least three ways to discover the format of a netCDF
file, i.e., whether it is a classic (32-bit offset) or newer 64-bit
offset netCDF3 format, or is netCDF4 format.  Each method returns the
information using slightly different terminology that becomes easier to
understand with practice.

   First, examine the end of the first line of global metadata output by
`ncks -M': 
     % ncks -M foo_3c.nc
     Opened file foo_3c.nc: dimensions = 19, variables = 261, global atts. = 4,
       id = 65536, type = NC_FORMAT_CLASSIC
     % ncks -M foo_364.nc
     Opened file foo_364.nc: dimensions = 19, variables = 261, global atts. = 4,
       id = 65536, type = NC_FORMAT_64BIT
     % ncks -M foo_4c.nc
     Opened file foo_4c.nc: dimensions = 19, variables = 261, global atts. = 4,
       id = 65536, type = NC_FORMAT_NETCDF4_CLASSIC
     % ncks -M foo_4.nc
     Opened file foo_4.nc: dimensions = 19, variables = 261, global atts. = 4,
       id = 65536, type = NC_FORMAT_NETCDF4
   This method requires a netCDF4-enabled NCO version 3.9.0+ (i.e.,
from 2007 or later).

   Second, query the file with `ncdump -k': 
     % ncdump -k foo_3.nc
     classic
     % ncdump -k foo_364.nc
     64-bit-offset
     % ncdump -k foo_4c.nc
     netCDF-4 classic model
     % ncdump -k foo_4.nc
     netCDF-4
   This method requires a netCDF4-enabled netCDF 3.6.2+ (i.e., from
2007 or later).

   The third option uses the POSIX-standard `od' (octal dump) command: 
     % od -An -c -N4 foo_3c.nc
        C   D   F 001
     % od -An -c -N4 foo_364.nc
        C   D   F 002
     % od -An -c -N4 foo_4c.nc
      211   H   D   F
     % od -An -c -N4 foo_4.nc
      211   H   D   F
   This option works without NCO and `ncdump'.  Values of `C D F 001'
and `C D F 002' indicate 32-bit (classic) and 64-bit netCDF3 formats,
respectively, while values of `211 H D F' indicate the newer netCDF4
file format.


File: nco.info,  Node: Large File Support,  Next: Subsetting Variables,  Prev: Selecting Output File Format,  Up: Common features

3.10 Large File Support
=======================

Availability: All operators
Short options: none
Long options: none
NCO has Large File Support (LFS), meaning that NCO can write files
larger than 2 GB on some 32-bit operating systems with netCDF libraries
earlier than version 3.6.  If desired, LFS support must be configured
when both netCDF and NCO are installed.  netCDF versions 3.6 and higher
support 64-bit file addresses as part of the netCDF standard.  We
recommend that users ignore LFS support which is difficult to configure
and is implemented in NCO only to support netCDF versions prior to 3.6.
This obviates the need for configuring explicit LFS support in
applications (such as NCO) which now support 64-bit files directly
through the netCDF interface.  See *note Selecting Output File Format::
for instructions on accessing the different file formats, including
64-bit files, supported by the modern netCDF interface.

   If you are still interesting in explicit LFS support for netCDF
versions prior to 3.6, know that LFS support depends on a complex,
interlocking set of operating system (1) and netCDF suppport issues.
The netCDF LFS FAQ at
`http://my.unidata.ucar.edu/content/software/netcdf/faq-lfs.html'
describes the various file size limitations imposed by different
versions of the netCDF standard.  NCO and netCDF automatically attempt
to configure LFS at build time.

   ---------- Footnotes ----------

   (1) Linux and AIX are known to support LFS.


File: nco.info,  Node: Subsetting Variables,  Next: Subsetting Coordinate Variables,  Prev: Large File Support,  Up: Common features

3.11 Subsetting Variables
=========================

Availability: (`ncap2'), `ncbo', `ncea', `ncecat', `ncflint', `ncks',
`ncpdq', `ncra', `ncrcat', `ncwa'
Short options: `-v', `-x'
Long options: `--variable', `--exclude' or `--xcl'
Subsetting variables refers to explicitly specifying variables to be
included or excluded from operator actions.  Subsetting is implemented
with the `-v VAR[,...]' and `-x' options.  A list of variables to
extract is specified following the `-v' option, e.g., `-v time,lat,lon'.
Not using the `-v' option is equivalent to specifying all variables.
The `-x' option causes the list of variables specified with `-v' to be
_excluded_ rather than _extracted_.  Thus `-x' saves typing when you
only want to extract fewer than half of the variables in a file.

   Variables explicitly specified for extraction with `-v VAR[,...]'
_must_ be present in the input file or an error will result.  Variables
explicitly specified for _exclusion_ with `-x -v VAR[,...]' need not be
present in the input file.  Remember, if averaging or concatenating
large files stresses your systems memory or disk resources, then the
easiest solution is often to use the `-v' option to retain only the
most important variables (*note Memory Requirements::).

   Due to its special capabilities, `ncap2' interprets the `-v' switch
differently (*note ncap2 netCDF Arithmetic Processor::).  For `ncap2',
the `-v' switch takes no arguments and indicates that _only_
user-defined variables should be output.  `ncap2' neither accepts nor
understands the -X switch.

   As of NCO 2.8.1 (August, 2003), variable name arguments of the `-v'
switch may contain "extended regular expressions".  As of NCO 3.9.6
(January, 2009), variable names arguments to `ncatted' may contain
"extended regular expressions".  For example, `-v '^DST'' selects all
variables beginning with the string `DST'.  Extended regular
expressions are defined by the GNU `egrep' command.  The
meta-characters used to express pattern matching operations are
`^$+?.*[]{}|'.  If the regular expression pattern matches _any_ part of
a variable name then that variable is selected.  This capability is
called "wildcarding", and is very useful for sub-setting large data
files.

   Because of its wide availability, NCO uses the POSIX regular
expression library `regex'.  Regular expressions of arbitary complexity
may be used.  Since netCDF variable names are relatively simple
constructs, only a few varieties of variable wildcards are likely to be
useful.  For convenience, we define the most useful pattern matching
operators here: 
`^'
     Matches the beginning of a string

`$'
     Matches the end of a string

`.'
     Matches any single character
   The most useful repetition and combination operators are 
`?'
     The preceding regular expression is optional and matched at most
     once

`*'
     The preceding regular expression will be matched zero or more times

`+'
     The preceding regular expression will be matched one or more times

`|'
     The preceding regular expression will be joined to the following
     regular expression.  The resulting regular expression matches any
     string matching either subexpression.
   To illustrate the use of these operators in extracting variables,
consider a file with variables `Q', `Q01'-`Q99', `Q100', `QAA'-`QZZ',
`Q_H2O', `X_H2O', `Q_CO2', `X_CO2'.
     ncks -v 'Q.?' in.nc              # Variables that contain Q
     ncks -v '^Q.?' in.nc             # Variables that start with Q
     ncks -v '^Q+.?.' in.nc           # Q, Q0--Q9, Q01--Q99, QAA--QZZ, etc.
     ncks -v '^Q..' in.nc             # Q01--Q99, QAA--QZZ, etc.
     ncks -v '^Q[0-9][0-9]' in.nc     # Q01--Q99, Q100
     ncks -v '^Q[[:digit:]]{2}' in.nc # Q01--Q99
     ncks -v 'H2O$' in.nc             # Q_H2O, X_H2O
     ncks -v 'H2O$|CO2$' in.nc        # Q_H2O, X_H2O, Q_CO2, X_CO2
     ncks -v '^Q[0-9][0-9]$' in.nc    # Q01--Q99
     ncks -v '^Q[0-6][0-9]|7[0-3]' in.nc # Q01--Q73, Q100
     ncks -v '(Q[0-6][0-9]|7[0-3])$' in.nc # Q01--Q73
     ncks -v '^[a-z]_[a-z]{3}$' in.nc # Q_H2O, X_H2O, Q_CO2, X_CO2
   Beware--two of the most frequently used repetition pattern matching
operators, `*' and `?', are also valid pattern matching operators for
filename expansion (globbing) at the shell-level.  Confusingly, their
meanings in extended regular expressions and in shell-level filename
expansion are significantly different.  In an extended regular
expression, `*' matches zero or more occurences of the preceding
regular expression.  Thus `Q*' selects all variables, and `Q+.*'
selects all variables containing `Q' (the `+' ensures the preceding item
matches at least once).  To match zero or one occurence of the
preceding regular expression, use `?'.  Documentation for the UNIX
`egrep' command details the extended regular expressions which NCO
supports.

   One must be careful to protect any special characters in the regular
expression specification from being interpreted (globbed) by the shell.
This is accomplish by enclosing special characters within single or
double quotes
     ncra -v Q?? in.nc out.nc   # Error: Shell attempts to glob wildcards
     ncra -v '^Q+..' in.nc out.nc # Correct: NCO interprets wildcards
     ncra -v '^Q+..' in*.nc out.nc # Correct: NCO interprets, Shell globs
   The final example shows that commands may use a combination of
variable wildcarding and shell filename expansion (globbing).  For
globbing, `*' and `?' _have nothing to do_ with the preceding regular
expression!  In shell-level filename expansion, `*' matches any string,
including the null string and `?' matches any single character.
Documentation for `bash' and `csh' describe the rules of filename
expansion (globbing).


File: nco.info,  Node: Subsetting Coordinate Variables,  Next: C and Fortran Index Conventions,  Prev: Subsetting Variables,  Up: Common features

3.12 Subsetting Coordinate Variables
====================================

Availability: `ncap2', `ncbo', `ncea', `ncecat', `ncflint', `ncks',
`ncpdq', `ncra', `ncrcat', `ncwa'
Short options: `-C', `-c'
Long options: `--no-coords', `--no-crd', `--crd', `--coords'
By default, coordinates variables associated with any variable appearing
in the INPUT-FILE will also appear in the OUTPUT-FILE, even if they are
not explicitly specified, e.g., with the `-v' switch.  Thus variables
with a latitude coordinate `lat' always carry the values of `lat' with
them into the OUTPUT-FILE.  This feature can be disabled with `-C',
which causes NCO to not automatically add coordinates to the variables
appearing in the OUTPUT-FILE.  However, using `-C' does not preclude
the user from including some coordinates in the output files simply by
explicitly selecting the coordinates with the -V option.  The `-c'
option, on the other hand, is a shorthand way of automatically
specifying that _all_ coordinate variables in the INPUT-FILES should
appear in the OUTPUT-FILE.  Thus `-c' allows the user to select all the
coordinate variables without having to know their names.  Both `-c' and
`-C' honor the CF `coordinates' convention described in *note CF
Conventions::.


File: nco.info,  Node: C and Fortran Index Conventions,  Next: Hyperslabs,  Prev: Subsetting Coordinate Variables,  Up: Common features

3.13 C and Fortran Index conventions
====================================

Availability: `ncbo', `ncea', `ncecat', `ncflint', `ncks', `ncpdq',
`ncra', `ncrcat', `ncwa'
Short options: `-F'
Long options: `--fortran'
The `-F' switch changes NCO to read and write with the Fortran index
convention.  By default, NCO uses C-style (0-based) indices for all I/O.
In C, indices count from 0 (rather than 1), and dimensions are ordered
from slowest (inner-most) to fastest (outer-most) varying.  In Fortran,
indices count from 1 (rather than 0), and dimensions are ordered from
fastest (inner-most) to slowest (outer-most) varying.  Hence C and
Fortran data storage conventions represent mathematical transposes of
eachother.  Note that record variables contain the record dimension as
the most slowly varying dimension.  See *note ncpdq netCDF Permute
Dimensions Quickly:: for techniques to re-order (including transpose)
dimensions and to reverse data storage order.

   Consider a file `85.nc' containing 12 months of data in the record
dimension `time'.  The following hyperslab operations produce identical
results, a June-July-August average of the data:
     ncra -d time,5,7 85.nc 85_JJA.nc
     ncra -F -d time,6,8 85.nc 85_JJA.nc

   Printing variable THREE_DMN_VAR in file `in.nc' first with the
C indexing convention, then with Fortran indexing convention results in
the following output formats:
     % ncks -v three_dmn_var in.nc
     lat[0]=-90 lev[0]=1000 lon[0]=-180 three_dmn_var[0]=0
     ...
     % ncks -F -v three_dmn_var in.nc
     lon(1)=0 lev(1)=100 lat(1)=-90 three_dmn_var(1)=0
     ...


File: nco.info,  Node: Hyperslabs,  Next: Stride,  Prev: C and Fortran Index Conventions,  Up: Common features

3.14 Hyperslabs
===============

Availability: `ncbo', `ncea', `ncecat', `ncflint', `ncks', `ncpdq',
`ncra', `ncrcat', `ncwa'
Short options: `-d DIM,[MIN][,[MAX][,[STRIDE]]]'
Long options: `--dimension DIM,[MIN][,[MAX][,[STRIDE]]]',
`--dmn DIM,[MIN][,[MAX][,[STRIDE]]]'
A "hyperslab" is a subset of a variable's data.  The coordinates of a
hyperslab are specified with the `-d DIM,[MIN][,[MAX][,[STRIDE]]]' short
option (or with the same arguments to the `--dimension' or `--dmn' long
options).  At least one hyperslab argument (MIN, MAX, or STRIDE) must
be present.  The bounds of the hyperslab to be extracted are specified
by the associated MIN and MAX values.  A half-open range is specified
by omitting either the MIN or MAX parameter.  The separating comma must
be present to indicate the omission of one of these arguments.  The
unspecified limit is interpreted as the maximum or minimum value in the
unspecified direction.  A cross-section at a specific coordinate is
extracted by specifying only the MIN limit and omitting a trailing
comma.  Dimensions not mentioned are passed with no reduction in range.
The dimensionality of variables is not reduced (in the case of a
cross-section, the size of the constant dimension will be one).  If
values of a coordinate-variable are used to specify a range or
cross-section, then the coordinate variable must be monotonic (values
either increasing or decreasing).  In this case, command-line values
need not exactly match coordinate values for the specified dimension.
Ranges are determined by seeking the first coordinate value to occur in
the closed range [MIN,MAX] and including all subsequent values until
one falls outside the range.  The coordinate value for a cross-section
is the coordinate-variable value closest to the specified value and
must lie within the range or coordinate-variable values.

   Coordinate values should be specified using real notation with a
decimal point required in the value, whereas dimension indices are
specified using integer notation without a decimal point.  This
convention serves only to differentiate coordinate values from
dimension indices.  It is independent of the type of any netCDF
coordinate variables.  For a given dimension, the specified limits must
both be coordinate values (with decimal points) or dimension indices
(no decimal points).  The STRIDE option, if any, must be a dimension
index, not a coordinate value.  *Note Stride::, for more information on
the STRIDE option.

   User-specified coordinate limits are promoted to double precision
values while searching for the indices which bracket the range.  Thus,
hyperslabs on coordinates of type `NC_BYTE' and `NC_CHAR' are computed
numerically rather than lexically, so the results are unpredictable.

   The relative magnitude of MIN and MAX indicate to the operator
whether to expect a "wrapped coordinate" (*note Wrapped Coordinates::),
such as longitude.  If MIN > MAX, the NCO expects the coordinate to be
wrapped, and a warning message will be printed.  When this occurs, NCO
selects all values outside the domain [MAX < MIN], i.e., all the values
exclusive of the values which would have been selected if MIN and MAX
were swapped.  If this seems confusing, test your command on just the
coordinate variables with `ncks', and then examine the output to ensure
NCO selected the hyperslab you expected (coordinate wrapping is
currently only supported by `ncks').

   Because of the way wrapped coordinates are interpreted, it is very
important to make sure you always specify hyperslabs in the
monotonically increasing sense, i.e., MIN < MAX (even if the underlying
coordinate variable is monotonically decreasing).  The only exception
to this is when you are indeed specifying a wrapped coordinate.  The
distinction is crucial to understand because the points selected by,
e.g., `-d longitude,50.,340.', are exactly the complement of the points
selected by `-d longitude,340.,50.'.

   Not specifying any hyperslab option is equivalent to specifying full
ranges of all dimensions.  This option may be specified more than once
in a single command (each hyperslabbed dimension requires its own `-d'
option).


File: nco.info,  Node: Stride,  Next: Multislabs,  Prev: Hyperslabs,  Up: Common features

3.15 Stride
===========

Availability: `ncbo', `ncea', `ncecat', `ncflint', `ncks', `ncpdq',
`ncra', `ncrcat', `ncwa'
Short options: `-d DIM,[MIN][,[MAX][,[STRIDE]]]'
Long options: `--dimension DIM,[MIN][,[MAX][,[STRIDE]]]',
`--dmn DIM,[MIN][,[MAX][,[STRIDE]]]'
All data operators support specifying a "stride" for any and all
dimensions at the same time.  The STRIDE is the spacing between
consecutive points in a hyperslab.  A STRIDE of 1 picks all the
elements of the hyperslab, and a STRIDE of 2 skips every other element,
etc..  `ncks' multislabs support strides, and are more powerful than
the regular hyperslabs supported by the other operators (*note
Multislabs::).  Using the STRIDE option for the record dimension with
`ncra' and `ncrcat' makes it possible, for instance, to average or
concatenate regular intervals across multi-file input data sets.

   The STRIDE is specified as the optional fourth argument to the `-d'
hyperslab specification: `-d DIM,[MIN][,[MAX][,[STRIDE]]]'.  Specify
STRIDE as an integer (i.e., no decimal point) following the third comma
in the `-d' argument.  There is no default value for STRIDE.  Thus
using `-d time,,,2' is valid but `-d time,,,2.0' and `-d time,,,' are
not.  When STRIDE is specified but MIN is not, there is an ambiguity as
to whether the extracted hyperslab should begin with (using C-style,
0-based indexes) element 0 or element `stride-1'.  NCO must resolve
this ambiguity and it chooses element 0 as the first element of the
hyperslab when MIN is not specified.  Thus `-d time,,,STRIDE' is
syntactically equivalent to `-d time,0,,STRIDE'.  This means, for
example, that specifying the operation `-d time,,,2' on the array
`1,2,3,4,5' selects the hyperslab `1,3,5'.  To obtain the hyperslab
`2,4' instead, simply explicitly specify the starting index as 1, i.e.,
`-d time,1,,2'.

   For example, consider a file `8501_8912.nc' which contains 60
consecutive months of data.  Say you wish to obtain just the March data
from this file.  Using 0-based subscripts (*note C and Fortran Index
Conventions::) these data are stored in records 2, 14, ... 50 so the
desired STRIDE is 12.  Without the STRIDE option, the procedure is very
awkward.  One could use `ncks' five times and then use `ncrcat' to
concatenate the resulting files together: 
     for idx in 02 14 26 38 50; do # Bourne Shell
       ncks -d time,${idx} 8501_8912.nc foo.${idx}
     done
     foreach idx (02 14 26 38 50) # C Shell
       ncks -d time,${idx} 8501_8912.nc foo.${idx}
     end
     ncrcat foo.?? 8589_03.nc
     rm foo.??
   With the STRIDE option, `ncks' performs this hyperslab extraction in
one operation:
     ncks -d time,2,,12 8501_8912.nc 8589_03.nc
   *Note ncks netCDF Kitchen Sink::, for more information on `ncks'.

   Applying the STRIDE option to the record dimension in `ncra' and
`ncrcat' makes it possible, for instance, to average or concatenate
regular intervals across multi-file input data sets.
     ncra -F -d time,3,,12 85.nc 86.nc 87.nc 88.nc 89.nc 8589_03.nc
     ncrcat -F -d time,3,,12 85.nc 86.nc 87.nc 88.nc 89.nc 8503_8903.nc


File: nco.info,  Node: Multislabs,  Next: Wrapped Coordinates,  Prev: Stride,  Up: Common features

3.16 Multislabs
===============

Availability: `ncbo', `ncea', `ncecat', `ncflint', `ncks', `ncpdq',
`ncra', `ncrcat'
Short options: `-d DIM,[MIN][,[MAX][,[STRIDE]]]'
Long options: `--dimension DIM,[MIN][,[MAX][,[STRIDE]]]',
`--dmn DIM,[MIN][,[MAX][,[STRIDE]]]'
A multislab is a union of one or more hyperslabs.  One defines
multislabs by chaining together hyperslab commands, i.e., `-d' options
(*note Hyperslabs::).  Support for specifying a "multi-hyperslab" or
"multislab" for any variable was first added to `ncks' in late 2002.
The other operators received MSA capabilities in April 2008.  Sometimes
multi-slabbing is referred to by the acronym MSA, which stands for
"Multi-Slabbing Algorithm".

   Multislabs overcome some restraints that limit hyperslabs.  A single
`-d' option can only specify a contiguous and/or a regularly spaced
multi-dimensional data array.  Multislabs are constructed from multiple
`-d' options and may therefore have non-regularly spaced arrays.  For
example, suppose it is desired to operate on all longitudes from 10.0
to 20.0 and from 80.0 to 90.0 degrees.  The combined range of
longitudes is not selectable in a single hyperslab specfication of the
form `-d DIMENSION,MIN,MAX' or `-d DIMENSION,MIN,MAX,STRIDE' because its
elements are irregularly spaced in coordinate space (and presumably in
index space too).  The multislab specification for obtaining these
values is simply the union of the hyperslabs specifications that
comprise the multislab, i.e.,
     ncks -d lon,10.,20. -d lon,80.,90. in.nc out.nc
     ncks -d lon,10.,15. -d lon,15.,20. -d lon,80.,90. in.nc out.nc
   Any number of hyperslabs specifications may be chained together to
specify the multislab.

   Users may specify redundant ranges of indices in a multislab, e.g.,
     ncks -d lon,0,4 -d lon,2,9,2 in.nc out.nc
   This command retrieves the first five longitudes, and then every
other longitude value up to the tenth.  Elements 0, 2, and 4 are
specified by both hyperslab arguments (hence this is redundant) but
will count only once if an arithmetic operation is being performed.
This example uses index-based (not coordinate-based) multislabs because
the STRIDE option only supports index-based hyper-slabbing.  *Note
Stride::, for more information on the STRIDE option.

   Multislabs are more efficient than the alternative of sequentially
performing hyperslab operations and concatenating the results.  This is
because NCO employs a novel multislab algorithm to minimize the number
of I/O operations when retrieving irregularly spaced data from disk.
The NCO multislab algorithm retrieves each element from disk once and
only once.  Thus users may take some shortcuts in specifying multislabs
and the algorithm will obtain the intended values.  Specifying
redundant ranges is not encouraged, but may be useful on occasion and
will not result in unintended consequences.

   A final example shows the real power of multislabs.  Suppose the Q
variable contains three dimensional arrays of distinct chemical
constituents in no particular order.  We are interested in the NOy
species in a certain geographic range.  Say that NO, NO2, and N2O5 are
elements 0, 1, and 5 of the SPECIES dimension of Q.  The multislab
specification might look something like
     ncks -d species,0,1 -d species,5 -d lon,0,4 -d lon,2,9,2 in.nc out.nc
   Multislabs are powerful because they may be specified for every
dimension at the same time.  Thus multislabs obsolete the need to
execute multiple `ncks' commands to gather the desired range of data.


File: nco.info,  Node: Wrapped Coordinates,  Next: Auxiliary Coordinates,  Prev: Multislabs,  Up: Common features

3.17 Wrapped Coordinates
========================

Availability: `ncks'
Short options: `-d DIM,[MIN][,[MAX][,[STRIDE]]]'
Long options: `--dimension DIM,[MIN][,[MAX][,[STRIDE]]]',
`--dmn DIM,[MIN][,[MAX][,[STRIDE]]]'
A "wrapped coordinate" is a coordinate whose values increase or
decrease monotonically (nothing unusual so far), but which represents a
dimension that ends where it begins (i.e., wraps around on itself).
Longitude (i.e., degrees on a circle) is a familiar example of a wrapped
coordinate.  Longitude increases to the East of Greenwich, England,
where it is defined to be zero.  Halfway around the globe, the
longitude is 180 degrees East (or West).  Continuing eastward,
longitude increases to 360 degrees East at Greenwich.  The longitude
values of most geophysical data are either in the range [0,360), or
[-180,180).  In either case, the Westernmost and Easternmost longitudes
are numerically separated by 360 degrees, but represent contiguous
regions on the globe.  For example, the Saharan desert stretches from
roughly 340 to 50 degrees East.  Extracting the hyperslab of data
representing the Sahara from a global dataset presents special problems
when the global dataset is stored consecutively in longitude from 0 to
360 degrees.  This is because the data for the Sahara will not be
contiguous in the INPUT-FILE but is expected by the user to be
contiguous in the OUTPUT-FILE.  In this case, `ncks' must invoke
special software routines to assemble the desired output hyperslab from
multiple reads of the INPUT-FILE.

   Assume the domain of the monotonically increasing longitude
coordinate `lon' is 0 < LON < 360.  `ncks' will extract a hyperslab
which crosses the Greenwich meridian simply by specifying the
westernmost longitude as MIN and the easternmost longitude as MAX.  The
following commands extract a hyperslab containing the Saharan desert:
     ncks -d lon,340.,50. in.nc out.nc
     ncks -d lon,340.,50. -d lat,10.,35. in.nc out.nc
   The first example selects data in the same longitude range as the
Sahara.  The second example further constrains the data to having the
same latitude as the Sahara.  The coordinate `lon' in the OUTPUT-FILE,
`out.nc', will no longer be monotonic!  The values of `lon' will be,
e.g., `340, 350, 0, 10, 20, 30, 40, 50'.  This can have serious
implications should you run `out.nc' through another operation which
expects the `lon' coordinate to be monotonically increasing.
Fortunately, the chances of this happening are slim, since `lon' has
already been hyperslabbed, there should be no reason to hyperslab `lon'
again.  Should you need to hyperslab `lon' again, be sure to give
dimensional indices as the hyperslab arguments, rather than coordinate
values (*note Hyperslabs::).


File: nco.info,  Node: Auxiliary Coordinates,  Next: UDUnits Support,  Prev: Wrapped Coordinates,  Up: Common features

3.18 Auxiliary Coordinates
==========================

Availability: `ncbo', `ncea', `ncecat', `ncflint', `ncks', `ncpdq',
`ncra', `ncrcat'
Short options: `-X LON_MIN,LON_MAX,LAT_MIN,LAT_MAX'
Long options: `--auxiliary LON_MIN,LON_MAX,LAT_MIN,LAT_MAX'
Utilize auxiliary coordinates specified in values of coordinate
variable's `standard_name' attributes, if any, when interpreting
hyperslab and multi-slab options.  Also `--auxiliary'.  This switch
supports hyperslabbing cell-based grids over coordinate ranges.  This
works on datasets that associate coordinate variables to grid-mappings
using the CF-convention (*note CF Conventions::) `coordinates' and
`standard_name' attributes described here
(http://cf-pcmdi.llnl.gov/documents/cf-conventions/1.1/cf-conventions.html#coordinate-system).
Currently, NCO understands auxiliary coordinate variables pointed to by
the `standard_name' attributes for LATITUDE and LONGITUDE.  Cells that
contain a value within the user-specified range
[LON_MIN,LON_MAX,LAT_MIN,LAT_MAX] are included in the output hyperslab.

   A cell-based grid collapses the horizontal spatial information
(latitude and longitude) and stores it along a one-dimensional
coordinate that has a one-to-one mapping to both latitude and longitude
coordinates.  Rectangular (in longitude and latitude) horizontal
hyperslabs cannot be selected using the typical procedure (*note
Hyperslabs::) of separately specifying `-d' arguments for longitude and
latitude.  Instead, when the `-X' is used, NCO learns the names of the
latitude and longitude coordinates by searching the `standard_name'
attribute of all variables until it finds the two variables whose
`standard_name''s are "latitude" and "longitude", respectively.  This
`standard_name' attribute for latitude and longitude coordinates
follows the CF-convention (*note CF Conventions::).

   Putting it all together, consider a variable GDS_3DVAR output from
simulations on a cell-based geodesic grid.  Although the variable
contains three dimensions of data (time, latitude, and longitude), it
is stored in the netCDF file with only two dimensions, `time' and
`gds_crd'.
     % ncks -m -C -v gds_3dvar ~/nco/data/in.nc
     gds_3dvar: # dim. = 2, NC_FLOAT, # att. = 4, ID = 38
     gds_3dvar dimension 0: time, size = 10 NC_DOUBLE, dim. ID = 18 (CRD)(REC)
     gds_3dvar dimension 1: gds_crd, size = 8 NC_FLOAT, dim. ID = 17 (CRD)
     gds_3dvar memory size is 10*8*nco_typ_lng(NC_FLOAT) = 80*4 = 320 bytes
     gds_3dvar attribute 0: long_name, size = 17 NC_CHAR, value = Geodesic variable
     gds_3dvar attribute 1: units, size = 5 NC_CHAR, value = meter
     gds_3dvar attribute 2: coordinates, size = 15 NC_CHAR, value = lat_gds lon_gds
   The `coordinates' attribute lists the names of the latitude and
longitude coordinates, `lat_gds' and `lon_gds', respectively.  The
`coordinates' attribute is recommended though optional.  With it, the
user can immediately identify which variables contain the latitude and
longitude coordinates.  Without a `coordinates' attribute it would be
unclear at first glance whether a variable is on a cell-based grid.  In
this example, `time' is a normal record dimension and `gds_crd' is the
cell-based dimension.

   The cell-based grid file must contain two variables whose
`standard_name' attributes are "latitude", and "longitude":
     % ncks -m -C -v lat_gds,lon_gds ~/nco/data/in.nc
     lat_gds: # dim. = 1, NC_DOUBLE, # att. = 4, ID = 34
     lat_gds dimension 0: gds_crd, size = 8 NC_FLOAT, dim. ID = 17 (CRD)
     lat_gds memory size is 8*nco_typ_lng(NC_DOUBLE) = 8*8 = 64 bytes
     lat_gds attribute 0: long_name, size = 8 NC_CHAR, value = Latitude
     lat_gds attribute 1: standard_name, size = 8 NC_CHAR, value = latitude
     lat_gds attribute 2: units, size = 6 NC_CHAR, value = degree

     lon_gds: # dim. = 1, NC_DOUBLE, # att. = 4, ID = 35
     lon_gds dimension 0: gds_crd, size = 8 NC_FLOAT, dim. ID = 17 (CRD)
     lon_gds memory size is 8*nco_typ_lng(NC_DOUBLE) = 8*8 = 64 bytes
     lon_gds attribute 0: long_name, size = 9 NC_CHAR, value = Longitude
     lon_gds attribute 1: standard_name, size = 9 NC_CHAR, value = longitude
     lon_gds attribute 2: units, size = 6 NC_CHAR, value = degree
   In this example `lat_gds' and `lon_gds' represent the latitude or
longitude, respectively, of cell-based variables.  These coordinates
(must) have the same single dimension (`gds_crd', in this case) as the
cell-based variables.  And the coordinates must be
one-dimensional--multidimensional coordinates will not work.

   This infrastructure allows NCO to identify, interpret, and process
(e.g., hyperslab) the variables on cell-based grids as easily as it
works with regular grids.  To time-average all the values between zero
and 180 degrees longitude and between plus and minus 30 degress
latitude, we use
     ncra -O -X 0.,180.,-30.,30. -v gds_3dvar in.nc out.nc
   NCO accepts multiple `-X' arguments for cell-based grids
multi-slabs, just as it accepts multiple `-d' arguments for multi-slabs
of regular coordinates.
     ncra -O -X 0.,180.,-30.,30. -X 270.,315.,45.,90. in.nc out.nc
   The arguments to `-X' are always interpreted as floating point
numbers, i.e., as coordinate values rather than dimension indices so
that these two commands produce identical results
     ncra -X 0.,180.,-30.,30. in.nc out.nc
     ncra -X 0,180,-30,30 in.nc out.nc
   In contrast, arguments to `-d' require decimal places to be
recognized as coordinates not indices (*note Hyperslabs::).  We
recommend always using decimal points with `-X' arguments to avoid
confusion.


File: nco.info,  Node: UDUnits Support,  Next: Rebasing Time Coordinate,  Prev: Auxiliary Coordinates,  Up: Common features

3.19 UDUnits Support
====================

Availability: `ncbo', `ncea', `ncecat', `ncflint', `ncks', `ncpdq',
`ncra', `ncrcat', `ncwa'
Short options: `-d DIM,[MIN][,[MAX][,[STRIDE]]]'
Long options: `--dimension DIM,[MIN][,[MAX][,[STRIDE]]]',
`--dmn DIM,[MIN][,[MAX][,[STRIDE]]]'
There is more than one way to hyperskin a cat.  The UDUnits
(http://www.unidata.ucar.edu/packages/udunits) package provides a
library which, if present, NCO uses to translate user-specified
physical dimensions into the physical dimensions of data stored in
netCDF files.  Unidata provides UDUnits under the same terms as netCDF,
so sites should install both.  Compiling NCO with UDUnits support is
currently optional but may become required in a future version of NCO.

   Two examples suffice to demonstrate the power and convenience of
UDUnits support.  First, consider extraction of a variable containing
non-record coordinates with physical dimensions stored in MKS units.
In the following example, the user extracts all wavelengths in the
visible portion of the spectrum in terms of the units very frequently
used in visible spectroscopy, microns:
     % ncks -C -H -v wvl -d wvl,"0.4 micron","0.7 micron" in.nc
     wvl[0]=5e-07 meter
   The hyperslab returns the correct values because the WVL variable is
stored on disk with a length dimension that UDUnits recognizes in the
`units' attribute.  The automagical algorithm that implements this
functionality is worth describing since understanding it helps one
avoid some potential pitfalls.  First, the user includes the physical
units of the hyperslab dimensions she supplies, separated by a simple
space from the numerical values of the hyperslab limits.  She encloses
each coordinate specifications in quotes so that the shell does not
break the _value-space-unit_ string into separate arguments before
passing them to NCO.  Double quotes (`"foo"') or single quotes
(`'foo'') are equally valid for this purpose.  Second, NCO recognizes
that units translation is requested because each hyperslab argument
contains text characters and non-initial spaces.  Third, NCO determines
whether the WVL is dimensioned with a coordinate variable that has a
`units' attribute.  In this case, WVL itself is a coordinate variable.
The value of its `units' attribute is `meter'.  Thus WVL passes this
test so UDUnits conversion is attempted.  If the coordinate associated
with the variable does not contain a `units' attribute, then NCO aborts.
Fourth, NCO passes the specified and desired dimension strings (microns
are specified by the user, meters are required by NCO) to the UDUnits
library.  Fifth, the UDUnits library that these dimension are
commensurate and it returns the appropriate linear scaling factors to
convert from microns to meters to NCO.  If the units are incommensurate
(i.e., not expressible in the same fundamental MKS units), or are not
listed in the UDUnits database, then NCO aborts since it cannot
determine the user's intent.  Finally, NCO uses the scaling information
to convert the user-specified hyperslab limits into the same physical
dimensions as those of the corresponding cooridinate variable on disk.
At this point, NCO can perform a coordinate hyperslab using the same
algorithm as if the user had specified the hyperslab without requesting
units conversion.

   The translation and dimensional innterpretation of time coordinates
shows a more powerful, and probably more common, UDUnits application.
In this example, the user prints all data between the eighth and ninth
of December, 1999, from a variable whose time dimension is hours since
the year 1900:
     % ncks -H -C -v time_udunits -d time_udunits,"1999-12-08 \
       12:00:0.0","1999-12-09 00:00:0.0",2 in.nc foo2.nc
     time_udunits[1]=876018 hours since 1900-01-01 00:00:0.0
   Here, the user invokes the stride (*note Stride::) capability to
obtain every other timeslice.  This is possible because the UDUnits
feature is additive, not exclusive--it works in conjunction with all
other hyperslabbing (*note Hyperslabs::) options and in all operators
which support hyperslabbing.  The following example shows how one might
average data in a time period spread across multiple input files
     ncra -d time,"1939-09-09 12:00:0.0","1945-05-08 00:00:0.0" \
       in1.nc in2.nc in3.nc out.nc
   Note that there is no excess whitespace before or after the
individual elements of the `-d' argument.  This is important since, as
far as the shell knows, `-d' takes only _one_ command-line argument.
Parsing this argument into its component `DIM,[MIN][,[MAX][,[STRIDE]]]'
elements (*note Hyperslabs::) is the job of NCO.  When unquoted
whitespace is present between these elements, the shell passes NCO
arugment fragments which will not parse as intended.

   NCO implemented support for the UDUnits2 library with version 3.9.2
(August, 2007).  The UDUnits2
(http://www.unidata.ucar.edu/software/udunits/udunits-2/udunits2.html)
package supports non-ASCII characters and logarithmic units.  We are
interested in user-feedback on these features, which are relatively
un-tested with NCO.

   The UDUnits (http://www.unidata.ucar.edu/packages/udunits) package
documentation describes the supported formats of time dimensions.
Among the metadata conventions which adhere to these formats are the
Climate and Forecast (CF) Conventions (http://cf-pcmdi.llnl.gov) and the
Cooperative Ocean/Atmosphere Research Data Service (COARDS) Conventions
(http://ferret.wrc.noaa.gov/noaa_coop/coop_cdf_profile.html).  The
following `-d arguments' extract the same data using commonly
encountered time dimension formats:
     -d time,"1918-11-11 11:00:0.0","1939-09-09 00:00:0.0"
   All of these formats include at least one dash `-' in a non-leading
character position (a dash in a leading character position is a
negative sign).  NCO assumes that a non-leading dash in a limit string
indicates that a UDUnits date conversion is requested.

As of NCO 4.0.0 some of calendar attributes as specified by  the CF
conventions are supported. The unsupported types default to mixed
Gregorian/Julian as defined by UDUunits.
*Supported types:  *
     "365_day"/"no_leap", "360_day", "gregorian", "standard"

*Unsupported types:*
     "366_day"/"all_leap","proleptic_gregorian","julian","none"

An Example: Consider the following netcdf variable

     variables:
       double lon_cal(lon_cal) ;
         lon_cal:long_name = "lon_cal" ;
         lon_cal:units = "days since 1964-2-28 0:0:0" ;
         lon_cal:calendar = "365_day" ;
     data:
       lon_cal = 1,2,3,4,5,6,7,8,9,10;

     So the command
     "ncks -v lon_cal -d lon_cal,'1964-3-1 0:00:0.0','1964-3-4 00:00:0.0' in.nc out.nc"
     Results in the hyperslab lon_cal=1,2,3,4

   netCDF variables should always be stored with MKS (i.e., God's)
units, so that application programs may assume MKS dimensions apply to
all input variables.  The UDUnits feature is intended to alleviate some
of the NCO user's pain when handling MKS units.  It connects users who
think in human-friendly units (e.g., miles, millibars, days) to extract
data which are always stored in God's units, MKS (e.g., meters,
Pascals, seconds).  The feature is not intended to encourage writers to
store data in esoteric units (e.g., furlongs, pounds per square inch,
fortnights).


File: nco.info,  Node: Rebasing Time Coordinate,  Next: Missing Values,  Prev: UDUnits Support,  Up: Common features

3.20 Rebasing Time Coordinate
=============================

Availability: `ncra', `ncrcat' Short options: None

Time rebasing seeks to fix the following problem. we have a bunch files
to concatenate or average along a common record dimension/ coordinate.
The thing is although the record coordinate is in the same time units
in each file the date offset is different.
For example suppose the time co-ordinate is in hours and we have 31
files for each day in january. Witin each file is the variable
temperature *temp(time)*; and a time co-ordinate that goes from 0-23
hours. The time:units attribute from each file is as follows
     file01.nc -- time:units="hours since 1990-1-1"
     file02.nc -- time:units="hours since 1990-1-2"
     file03.nc -- time:units="hours since 1990-1-3"
     file04.nc -- time:units="hours since 1990-1-4"
     ...
     ...


     //Find the mean noon day temperature in january
     ncra -v temp -d time,"1990-1-1 12:00:00","1990-1-31 23:59:59",24 \
           file??.nc noon.nc

     // concatenate day2 noon - day3 noon records
     ncrcat -v temp -d time,"1990-1-2 12:00:00","1990-1-3 11:59:59" \
           file01.nc file02.nc file03.nc noon.nc

     // As you can see the time has been "rebased" to the time units in "file01.nc"
     time=36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52,
          53, 54, 55, 56, 57, 58, 59 ;

     // If we repeat the above command but with only two input files
     ncrcat -v temp -d time,"1990-1-2 12:00:00","1990-1-3 11:59:59" \
           file02.nc file03 noon.nc

     // then the output time coordinate is "based" on the time units in "file02.nc"
     time = 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28,
         29, 30, 31, 32, 33, 34, 35 ;


File: nco.info,  Node: Missing Values,  Next: Chunking,  Prev: Rebasing Time Coordinate,  Up: Common features

3.21 Missing values
===================

Availability: `ncap2', `ncbo', `ncea', `ncflint', `ncpdq', `ncra',
`ncwa'
Short options: None

   The phrase "missing data" refers to data points that are missing,
invalid, or for any reason not intended to be arithmetically processed
in the same fashion as valid data.  The NCO arithmetic operators
attempt to handle missing data in an intelligent fashion.  There are
four steps in the NCO treatment of missing data:
  1. Identifying variables that may contain missing data.

     NCO follows the convention that missing data should be stored with
     the _FILLVALUE specified in the variable's `_FillValue' attributes.
     The _only_ way NCO recognizes that a variable _may_ contain
     missing data is if the variable has a `_FillValue' attribute.  In
     this case, any elements of the variable which are numerically equal
     to the _FILLVALUE are treated as missing data.

     NCO adopted the behavior that the default attribute name, if any,
     assumed to specify the value of data to ignore is `_FillValue'
     with version 3.9.2 (August, 2007).  Prior to that, the
     `missing_value' attribute, if any, was assumed to specify the
     value of data to ignore.  Supporting both of these attributes
     simultaneously is not practical.  Hence the behavior NCO once
     applied to MISSING_VALUE it now applies to any _FILLVALUE.  NCO
     now treats any MISSING_VALUE as normal data (1).

     It has been and remains most advisable to create both `_FillValue'
     and `missing_value' attributes with identical values in datasets.
     Many legacy datasets contain only `missing_value' attributes.  NCO
     can help migrating datasets between these conventions.  One may
     use `ncrename' (*note ncrename netCDF Renamer::) to rename all
     `missing_value' attributes to `_FillValue':
          ncrename -a .missing_value,_FillValue inout.nc
     Alternatively, one may use `ncatted' (*note ncatted netCDF
     Attribute Editor::) to add a `_FillValue' attribute to all
     variables
          ncatted -O -a _FillValue,,o,f,1.0e36 inout.nc

  2. Converting the _FILLVALUE to the type of the variable, if
     neccessary.

     Consider a variable VAR of type VAR_TYPE with a `_FillValue'
     attribute of type ATT_TYPE containing the value _FILLVALUE.  As a
     guideline, the type of the `_FillValue' attribute should be the
     same as the type of the variable it is attached to.  If VAR_TYPE
     equals ATT_TYPE then NCO straightforwardly compares each value of
     VAR to _FILLVALUE to determine which elements of VAR are to be
     treated as missing data.  If not, then NCO converts _FILLVALUE from
     ATT_TYPE to VAR_TYPE by using the implicit conversion rules of C,
     or, if ATT_TYPE is `NC_CHAR' (2), by typecasting the results of
     the C function `strtod(_FILLVALUE)'.  You may use the NCO operator
     `ncatted' to change the `_FillValue' attribute and all data whose
     data is _FILLVALUE to a new value (*note ncatted netCDF Attribute
     Editor::).

  3. Identifying missing data during arithmetic operations.

     When an NCO arithmetic operator processes a variable VAR with a
     `_FillValue' attribute, it compares each value of VAR to
     _FILLVALUE before performing an operation.  Note the _FILLVALUE
     comparison imposes a performance penalty on the operator.
     Arithmetic processing of variables which contain the `_FillValue'
     attribute always incurs this penalty, even when none of the data
     are missing.  Conversely, arithmetic processing of variables which
     do not contain the `_FillValue' attribute never incurs this
     penalty.  In other words, do not attach a `_FillValue' attribute
     to a variable which does not contain missing data.  This
     exhortation can usually be obeyed for model generated data, but it
     may be harder to know in advance whether all observational data
     will be valid or not.

  4. Treatment of any data identified as missing in arithmetic
     operators.

     NCO averagers (`ncra', `ncea', `ncwa') do not count any element
     with the value _FILLVALUE towards the average.  `ncbo' and
     `ncflint' define a _FILLVALUE result when either of the input
     values is a _FILLVALUE.  Sometimes the _FILLVALUE may change from
     file to file in a multi-file operator, e.g., `ncra'.  NCO is
     written to account for this (it always compares a variable to the
     _FILLVALUE assigned to that variable in the current file).
     Suffice it to say that, in all known cases, NCO does "the right
     thing".

     It is impossible to determine and store the correct result of a
     binary operation in a single variable.  One such corner case
     occurs when both operands have differing _FILLVALUE attributes,
     i.e., attributes with different numerical values.  Since the
     output (result) of the operation can only have one _FILLVALUE,
     some information may be lost.  In this case, NCO always defines
     the output variable to have the same _FILLVALUE as the first input
     variable.  Prior to performing the arithmetic operation, all
     values of the second operand equal to the second _FILLVALUE are
     replaced with the first _FILLVALUE.  Then the arithmetic operation
     proceeds as normal, comparing each element of each operand to a
     single _FILLVALUE.  Comparing each element to two distinct
     _FILLVALUE's would be much slower and would be no likelier to
     yield a more satisfactory answer.  In practice, judicious choice
     of _FILLVALUE values prevents any important information from being
     lost.

   ---------- Footnotes ----------

   (1) The old functionality, i.e., where the ignored values are
indicated by `missing_value' not `_FillValue', may still be selected
_at NCO build time_ by compiling NCO with the token definition
`CPPFLAGS='-DNCO_MSS_VAL_SNG=missing_value''.

   (2) For example, the DOE ARM program often uses ATT_TYPE = `NC_CHAR'
and _FILLVALUE = `-99999.'.


File: nco.info,  Node: Chunking,  Next: Deflation,  Prev: Missing Values,  Up: Common features

3.22 Chunking
=============

Availability: `ncap2', `ncbo', `ncea', `ncecat', `ncflint', `ncks',
`ncpdq', `ncra', `ncrcat', `ncwa'
Short options: none
Long options: `--cnk_dmn DMN_NM,CNK_SZ', `--chunk_dimension
DMN_NM,CNK_SZ'
, `--cnk_map CNK_MAP', `--chunk_map CNK_MAP',
`--cnk_plc CNK_PLC', `--chunk_policy CNK_PLC',
`--cnk_scl CNK_SZ', `--chunk_scalar CNK_SZ'

   All netCDF4-enabled NCO operators that define variables support a
plethora of chunksize options.  Chunking can significantly accelerate
or degrade read/write access to large datasets.  Dataset chunking
issues are described in detail here
(http://www.hdfgroup.org/HDF5/doc/H5.user/Chunking.html).

   The NCO chunking implementation is designed to be flexible.  Users
control three aspects of the chunking implementation.  These are known
as the "chunking policy", "chunking map", and "chunksize".  The first
two are high-level mechanisms that apply to an entire file, while the
third allows per-dimension specification of parameters.  The
implementation is a hybrid of the `ncpdq' packing policies (*note ncpdq
netCDF Permute Dimensions Quickly::), and the hyperslab specifications
(*note Hyperslabs::).  Each aspect is intended to have a sensible
default, so that most users will only need to set one switch to obtain
sensible chunking.  Power users can tune the three switches in tandem
to obtain optimal performance.

   The user specifies the desired chunking policy with the `-P' switch
(or its long option equivalents, `--cnk_plc' and `--chunk_policy') and
its CNK_PLC argument.  Five chunking policies are currently implemented:
"Chunk All Variables [_default_]"
     Definition: Chunk all variables possible
     Alternate invocation: `ncchunk'
     CNK_PLC key values: `all', `cnk_all', `plc_all'
     Mnemonic: All
"Chunk Variables with at least Two Dimensions"
     Definition: Chunk all variables possible with at least two
     dimensions
     Alternate invocation: none
     CNK_PLC key values: `g2d', `cnk_g2d', `plc_g2d'
     Mnemonic: _G_reater than or equal to _2_ _D_imensions
"Chunk Variables with at least Three Dimensions"
     Definition: Chunk all variables possible with at least three
     dimensions
     Alternate invocation: none
     CNK_PLC key values: `g3d', `cnk_g3d', `plc_g3d'
     Mnemonic: _G_reater than or equal to _3_ _D_imensions
"Chunk Variables Containing Explicitly Chunked Dimensions"
     Definition: Chunk all variables possible that contain at least one
     dimension whose chunksize was explicitly set with the `--cnk_dmn'
     option.  Alternate invocation: none
     CNK_PLC key values: `xpl', `cnk_xpl', `plc_xpl'
     Mnemonic: E_XPL_icitly specified dimensions
"Unchunking"
     Definition: Unchunk all variables
     Alternate invocation: `ncunchunk'
     CNK_PLC key values: `uck', `cnk_uck', `plc_uck', `unchunk'
     Mnemonic: _U_n_C_hun_K_
Equivalent key values are fully interchangeable.  Multiple equivalent
options are provided to satisfy disparate needs and tastes of NCO users
working with scripts and from the command line.

   The chunking algorithms must know the chunksizes of each dimension of
each variable to be chunked.  The correspondence between the input
variable shape and the chunksizes is called the "chunking map".  The
user specifies the desired chunking map with the `-M' switch (or its
long option equivalents, `--cnk_map' and `--chunk_map') and its CNK_MAP
argument.  Four chunking maps are currently implemented:
"Chunksize Equals Dimension Size [_default_]"
     Definition: Chunksize defaults to dimension size.  Explicitly
     specify chunksizes for particular dimensions with `--cnk_dmn'
     option.
     CNK_MAP key values: `dmn', `cnk_dmn', `map_dmn'
     Mnemonic: _D_i_M_e_N_sion
"Chunksize Equals Dimension Size except Record Dimension"
     Definition: Chunksize equals dimension size except record
     dimension has size one.  Explicitly specify chunksizes for
     particular dimensions with `--cnk_dmn' option.
     CNK_MAP key values: `rd1', `cnk_rd1', `map_rd1'
     Mnemonic: _R_ecord _D_imension size _1_
"Chunksize Equals Scalar Size Specified"
     Definition: Chunksize for all dimensions is set with the
     `--cnk_scl' option.
     CNK_MAP key values: `xpl', `cnk_xpl', `map_xpl'
     Mnemonic: E_XPL_icitly specified dimensions
"Chunksize Product Equals Scalar Size Specified"
     Definition: The product of the chunksizes for each variable
     (approximately) equals the size specified with the `--cnk_scl'
     option.  For a variable of rank R (i.e., with R non-degenerate
     dimensions), the chunksize in each non-degenerate dimension is the
     Rth root of CNK_SCL.
     CNK_MAP key values: `prd', `cnk_prd', `map_prd'
     Mnemonic: _PR_o_D_uct
It is possible to combine the above chunking map algorithms with
user-specified per-dimension (but not per-variable) chunksizes that
override specific chunksizes determined by the maps above.  The user
specifies the per-dimension chunksizes with the (equivalent) long
options `--cnk_dmn' or `--chunk_dimension').  The option takes two
comma-separated arguments, DMN_NM,CNK_SZ, which are the dimension name
and its chunksize, respectively.  The `--cnk_dmn' option may be us as
many times as necessary.

     # Debugging
     ncks -O -4 -D 4 --cnk_scl=8 ~/nco/data/in.nc ~/foo.nc
     ncks -O -4 -D 4 --cnk_scl=8 /data/zender/dstmch90/dstmch90_clm.nc ~/foo.nc
     ncks -O -4 -D 4 --cnk_dmn lat,64 --cnk_dmn lon,128 /data/zender/dstmch90/dstmch90_clm.nc ~/foo.nc
     ncks -O -4 -D 4 --cnk_plc=uck ~/foo.nc ~/foo.nc
     ncks -O -4 -D 4 --cnk_plc=g2d --cnk_map=rd1 --cnk_dmn lat,64 --cnk_dmn lon,128 /data/zender/dstmch90/dstmch90_clm.nc ~/foo.nc

     # Chunk data then unchunk it back to its original state:
     ncks -O -4 -D 4 --cnk_plc=all ~/nco/data/in.nc ~/foo.nc
     ncks -O -4 -D 4 --cnk_plc=uck ~/foo.nc ~/foo.nc

     # Final, cleaner examples for manual
     ncks --cnk_plc=all     in.nc out.nc # Chunk in.nc
     ncks --cnk_plc=unchunk in.nc out.nc # Unchunk in.nc


File: nco.info,  Node: Deflation,  Next: Packed data,  Prev: Chunking,  Up: Common features

3.23 Deflation
==============

Availability: `ncap2', `ncbo', `ncea', `ncecat', `ncflint', `ncks',
`ncpdq', `ncra', `ncrcat', `ncwa'
Short options: `-L'
Long options: `--dfl_lvl', `--deflate'

   All NCO operators that define variables support the netCDF4 feature
of storing variables compressed with Lempel-Ziv deflation.  The
Lempel-Ziv algorithm is a lossless data compression technique.
Activate this deflation with the `-L DFL_LVL' short option (or with the
same argument to the `--dfl_lvl' or `--deflate' long options).  Specify
the deflation level DFL_LVL on a scale from no deflation (DFL_LVL = 0)
to maximum deflation (DFL_LVL = 9).  Minimal deflation (DFL_LVL = 1)
achieves considerable storage compression with little time penalty.
Higher deflation levels require more time for compression.  File sizes
resulting from minimal (DFL_LVL = 1) and maximal (DFL_LVL = 9)
deflation levels typically differ by a few percent in size.

   To compress an entire file using deflation, use
     ncks -4 -L 0 in.nc out.nc # No deflation (fast, no time penalty)
     ncks -4 -L 1 in.nc out.nc # Minimal deflation (little time penalty)
     ncks -4 -L 9 in.nc out.nc # Maximal deflation (much slower)

   Unscientific testing shows that deflation compresses typical climate
datasets by 30-60%.  Packing, a lossy compression technique available
for all netCDF files (see *note Packed data::), can easily compress
files by 50%.  Packed data may be deflated to squeeze datasets by about
80%.
     ncks  -4 -L 1 in.nc out.nc # Minimal deflation (~30-60% compression)
     ncks  -4 -L 9 in.nc out.nc # Maximal deflation (~31-63% compression)
     ncpdq         in.nc out.nc # Standard packing  (~50% compression)
     ncpdq -4 -L 9 in.nc out.nc # Deflated packing  (~80% compression)
   `ncks' prints deflation parameters, if any, to screen (*note ncks
netCDF Kitchen Sink::).


File: nco.info,  Node: Packed data,  Next: Operation Types,  Prev: Deflation,  Up: Common features

3.24 Packed data
================

Availability: `ncap2', `ncbo', `ncea', `ncflint', `ncpdq', `ncra',
`ncwa'
Short options: None

   The phrase "packed data" refers to data which are stored in the
standard netCDF3 packing format which employs a lossy algorithm.  See
*note ncks netCDF Kitchen Sink:: for a description of deflation, a
lossless compression technique available with netCDF4 only.  Packed
data may be deflated to save additional space.

Packing Algorithm
-----------------

"Packing" The standard netCDF packing algorithm is lossy, and produces
data with the same dynamic range as the original but which requires no
more than half the space to store.  The packed variable is stored
(usually) as type `NC_SHORT' with the two attributes required to unpack
the variable, `scale_factor' and `add_offset', stored at the original
(unpacked) precision of the variable (1).  Let MIN and MAX be the
minimum and maximum values of X.

   SCALE_FACTOR = (MAX-MIN)/NDRV
ADD_OFFSET = 0.5*(MIN+MAX)
PCK = (UPK-ADD_OFFSET)/SCALE_FACTOR = (UPK-0.5*(MIN+MAX))*NDRV/(MAX-MIN)

   where NDRV is the number of discrete representable values for given
type of packed variable.  The theoretical maximum value for NDRV is two
raised to the number of bits used to store the packed variable.  Thus
if the variable is packed into type `NC_SHORT', a two-byte datatype,
then there are at most 2^16 = 65536 distinct values representible.  In
practice, the number of discretely representible values is taken to be
one less than the theoretical maximum.  This leaves extra space and
solves potential problems with rounding which can occur during the
unpacking of the variable.  Thus for `NC_SHORT', ndrv = 65536 - 1 =
65535.  Less often, the variable may be packed into type `NC_CHAR',
where ndrv = 256 - 1 = 255, or type `NC_INT' where where ndrv =
4294967295 - 1 = 4294967294.  One useful feature of (lossy) netCDF
packing algorithm is that additional, loss-less packing algorithms
perform well on top of it.

Unpacking Algorithm
-------------------

"Unpacking" The unpacking algorithm depends on the presence of two
attributes, `scale_factor' and `add_offset'.  If `scale_factor' is
present for a variable, the data are multiplied by the value
SCALE_FACTOR after the data are read.  If `add_offset' is present for a
variable, then the ADD_OFFSET value is added to the data after the data
are read.  If both `scale_factor' and `add_offset' attributes are
present, the data are first scaled by SCALE_FACTOR before the offset
ADD_OFFSET is added.

   UPK = SCALE_FACTOR*PCK + ADD_OFFSET = (MAX-MIN)*PCK/NDRV +
0.5*(MIN+MAX)

   When `scale_factor' and `add_offset' are used for packing, the
associated variable (containing the packed data) is typically of type
`byte' or `short', whereas the unpacked values are intended to be of
type `int', `float', or `double'.  An attribute's `scale_factor' and
`add_offset' and `_FillValue', if any, should all be of the type
intended for the unpacked data, i.e., `int', `float' or `double'.

Default Handling of Packed Data
-------------------------------

All NCO arithmetic operators understand packed data.  The operators
automatically unpack any packed variable in the input file which will
be arithmetically processed.  For example, `ncra' unpacks all record
variables, and `ncwa' unpacks all variable which contain a dimension to
be averaged.  These variables are stored unpacked in the output file.

   On the other hand, arithmetic operators do not unpack non-processed
variables.  For example, `ncra' leaves all non-record variables packed,
and `ncwa' leaves packed all variables lacking an averaged dimension.
These variables (called fixed variables) are passed unaltered from the
input to the output file.  Hence fixed variables which are packed in
input files remain packed in output files.  Completely packing and
unpacking files is easily accomplished with `ncpdq' (*note ncpdq netCDF
Permute Dimensions Quickly::).  Packing and unpacking individual
variables may be done with `ncpdq' and the `ncap2' `pack()' and
`unpack()' functions (*note Methods and functions::).

   ---------- Footnotes ----------

   (1) Although not a part of the standard, NCO enforces the policy
that the `_FillValue' attribute, if any, of a packed variable is also
stored at the original precision.


File: nco.info,  Node: Operation Types,  Next: Type Conversion,  Prev: Packed data,  Up: Common features

3.25 Operation Types
====================

Availability: `ncap2', `ncra', `ncea', `ncwa'
Short options: `-y'
Long options: `--operation', `--op_typ'
The `-y OP_TYP' switch allows specification of many different types of
operations Set OP_TYP to the abbreviated key for the corresponding
operation:
`avg'
     Mean value

`sqravg'
     Square of the mean

`avgsqr'
     Mean of sum of squares

`max'
     Maximium value

`min'
     Minimium value

`rms'
     Root-mean-square (normalized by N)

`rmssdn'
     Root-mean square (normalized by N-1)

`sqrt'
     Square root of the mean

`ttl'
     Sum of values
   NCO assumes coordinate variables represent grid axes, e.g.,
longitude.  The only rank-reduction which makes sense for coordinate
variables is averaging.  Hence NCO implements the operation type
requested with `-y' on all non-coordinate variables, but not on
coorniate variables.  When an operation requires a coordinate variable
to be reduced in rank, i.e., from one dimension to a scalar or from one
dimension to a degenerate (single value) array, then NCO _always
averages_ the coordinate variable regardless of the arithmetic
operation type performed on the non-coordinate variables.

   The mathematical definition of each arithmetic operation is given
below.  *Note ncwa netCDF Weighted Averager::, for additional
information on masks and normalization.  If an operation type is not
specified with `-y' then the operator performs an arithmetic average by
default.  Averaging is described first so the terminology for the other
operations is familiar.

   _Note for Info users_: The definition of mathematical operations
involving rank reduction (e.g., averaging) relies heavily on
mathematical expressions which cannot be easily represented in Info.
_See the printed manual (./nco.pdf) for much more detailed and complete
documentation of this subject._

   The definitions of some of these operations are not universally
useful.  Mostly they were chosen to facilitate standard statistical
computations within the NCO framework.  We are open to redefining and
or adding to the above.  If you are interested in having other
statistical quantities defined in NCO please contact the NCO project
(*note Help Requests and Bug Reports::).

EXAMPLES

Suppose you wish to examine the variable `prs_sfc(time,lat,lon)' which
contains a time series of the surface pressure as a function of
latitude and longitude.  Find the minimium value of `prs_sfc' over all
dimensions:
     ncwa -y min -v prs_sfc in.nc foo.nc
   Find the maximum value of `prs_sfc' at each time interval for each
latitude:
     ncwa -y max -v prs_sfc -a lon in.nc foo.nc
   Find the root-mean-square value of the time-series of `prs_sfc' at
every gridpoint:
     ncra -y rms -v prs_sfc in.nc foo.nc
     ncwa -y rms -v prs_sfc -a time in.nc foo.nc
   The previous two commands give the same answer but `ncra' is
preferred because it has a smaller memory footprint.  Also, by default,
`ncra' leaves the (degenerate) `time' dimension in the output file
(which is usually useful) whereas `ncwa' removes the `time' dimension
(unless `-b' is given).

These operations work as expected in multi-file operators.  Suppose
that `prs_sfc' is stored in multiple timesteps per file across multiple
files, say `jan.nc', `feb.nc', `march.nc'.  We can now find the three
month maximium surface pressure at every point.
     ncea -y max -v prs_sfc jan.nc feb.nc march.nc out.nc

It is possible to use a combination of these operations to compute the
variance and standard deviation of a field stored in a single file or
across multiple files.  The procedure to compute the temporal standard
deviation of the surface pressure at all points in a single file
`in.nc' involves three steps.
     ncwa -O -v prs_sfc -a time in.nc out.nc
     ncbo -O -v prs_sfc in.nc out.nc out.nc
     ncra -O -y rmssdn out.nc out.nc
   First construct the temporal mean of `prs_sfc' in the file `out.nc'.
Next overwrite `out.nc' with the anomaly (deviation from the mean).
Finally overwrite `out.nc' with the root-mean-square of itself.  Note
the use of `-y rmssdn' (rather than `-y rms') in the final step.  This
ensures the standard deviation is correctly normalized by one fewer
than the number of time samples.  The procedure to compute the variance
is identical except for the use of `-y var' instead of `-y rmssdn' in
the final step.

   `ncap2' can also compute statistics like standard deviations.
Brute-force implementation of formulae is one option, e.g.,
     ncap2 -s 'prs_sfc_sdn=sqrt((prs_sfc-prs_sfc.avg($time)^2).total($time))/($time.size-1)'
           in.nc out.nc
   The operation may, of course, be broken into multiple steps in order
to archive intermediate quantities, such as the time-anomalies
     ncap2 -s 'prs_sfc_anm=prs_sfc-prs_sfc.avg($time)' \
           -s 'prs_sfc_sdn=sqrt((prs_sfc_anm^2).total($time))/($time.size-1)' \
           in.nc out.nc

   `ncap2' supports intrinsic standard deviation functions (*note
Operation Types::) which simplify the above expression to
     ncap2 -s 'prs_sfc_sdn=(prs_sfc-prs_sfc.avg($time)).rmssdn($time)' in.nc out.nc
   These instrinsic functions compute the answer quickly and concisely.

   The procedure to compute the spatial standard deviation of a field
in a single file `in.nc' involves three steps.
     ncwa -O -v prs_sfc,gw -a lat,lon -w gw in.nc out.nc
     ncbo -O -v prs_sfc,gw in.nc out.nc out.nc
     ncwa -O -y rmssdn -v prs_sfc -a lat,lon -w gw out.nc out.nc
   First the appropriately weighted (with `-w gw') spatial mean values
are written to the output file.  This example includes the use of a
weighted variable specified with `-w gw'.  When using weights to
compute standard deviations one must remember to include the weights in
the initial output files so that they may be used again in the final
step.  The initial output file is then overwritten with the gridpoint
deviations from the spatial mean.  Finally the root-mean-square of the
appropriately weighted spatial deviations is taken.

   The `ncap2' solution to the spatially-weighted standard deviation
problem is
     ncap2 -s 'prs_sfc_sdn=(prs_sfc*gw-prs_sfc*gw.avg($lat,$lon)).rmssdn($lat,$lon)' \
           in.nc out.nc
   Be sure to multiply the variable by the weight prior to computing the
the anomalies and the standard deviation.

   The procedure to compute the standard deviation of a time-series
across multiple files involves one extra step since all the input must
first be collected into one file.
     ncrcat -O -v tpt in.nc in.nc foo1.nc
     ncwa -O -a time foo1.nc foo2.nc
     ncbo -O -v tpt foo1.nc foo2.nc foo2.nc
     ncra -O -y rmssdn foo2.nc out.nc
   The first step assembles all the data into a single file.  This may
require a lot of temporary disk space, but is more or less required by
the `ncbo' operation in the third step.


File: nco.info,  Node: Type Conversion,  Next: Batch Mode,  Prev: Operation Types,  Up: Common features

3.26 Type Conversion
====================

Availability: `ncap2', `ncbo', `ncea', `ncra', `ncwa'
Short options: None
Type conversion (often called "promotion" or "demotion") refers to the
casting of one fundamental data type to another, e.g., converting
`NC_SHORT' (two bytes) to `NC_DOUBLE' (eight bytes).  Type conversion
is automatic when the language carries out this promotion according to
an internal set of rules without explicit user intervention.  In
contrast, manual type conversion refers to explicit user commands to
change the type of a variable or attribute.  Most type conversion
happens automatically, yet there are situations in which manual type
conversion is advantageous.

* Menu:

* Automatic type conversion::
* Manual type conversion::


File: nco.info,  Node: Automatic type conversion,  Next: Manual type conversion,  Prev: Type Conversion,  Up: Type Conversion

3.26.1 Automatic type conversion
--------------------------------

As a general rule, automatic type conversions should be avoided for at
least two reasons.  First, type conversions are expensive since they
require creating (temporary) buffers and casting each element of a
variable from the type it was stored at to some other type.  Second,
the dataset's creator probably had a good reason for storing data as,
say, `NC_FLOAT' rather than `NC_DOUBLE'.  In a scientific framework
there is no reason to store data with more precision than the
observations were made.  Thus NCO tries to avoid performing automatic
type conversions when performing arithmetic.

   Automatic type conversion during arithmetic in the languages C and
Fortran is performed only when necessary.  All operands in an operation
are converted to the most precise type before the operation takes place.
However, following this parsimonious conversion rule dogmatically
results in numerous headaches.  For example, the average of the two
`NC_SHORT's `17000s' and `17000s' results in garbage since the
intermediate value which holds their sum is also of type `NC_SHORT' and
thus cannot represent values greater than 32,767 (1).  There are valid
reasons for expecting this operation to succeed and the NCO philosophy
is to make operators do what you want, not what is most pure.  Thus,
unlike C and Fortran, but like many other higher level interpreted
languages, NCO arithmetic operators will perform automatic type
conversion when all the following conditions are met (2):
  1. The operator is `ncea', `ncra', or `ncwa'.  `ncbo' is not yet
     included in this list because subtraction did not benefit from
     type conversion.  This will change in the future

  2. The arithmetic operation could benefit from type conversion.
     Operations that could benefit (e.g., from larger representable
     sums) include averaging, summation, or any "hard" arithmetic.
     Type conversion does not benefit searching for minima and maxima
     (`-y min', or `-y max').

  3. The variable on disk is of type `NC_BYTE', `NC_CHAR', `NC_SHORT',
     or `NC_INT'.  Type `NC_DOUBLE' is not type converted because there
     is no type of higher precision to convert to.  Type `NC_FLOAT' is
     not type converted because, in our judgement, the performance
     penalty of always doing so would outweigh the (extremely rare)
     potential benefits.

   When these criteria are all met, the operator promotes the variable
in question to type `NC_DOUBLE', performs all the arithmetic
operations, casts the `NC_DOUBLE' type back to the original type, and
finally writes the result to disk.  The result written to disk may not
be what you expect, because of incommensurate ranges represented by
different types, and because of (lack of) rounding.  First, continuing
the above example, the average (e.g., `-y avg') of `17000s' and
`17000s' is written to disk as `17000s'.  The type conversion feature
of NCO makes this possible since the arithmetic and intermediate values
are stored as `NC_DOUBLE's, i.e., `34000.0d' and only the final result
must be represented as an `NC_SHORT'.  Without the type conversion
feature of NCO, the average would have been garbage (albeit predictable
garbage near `-15768s').  Similarly, the total (e.g., `-y ttl') of
`17000s' and `17000s' written to disk is garbage (actually `-31536s')
since the final result (the true total) of 34000 is outside the range
of type `NC_SHORT'.

   Type conversions use the `floor' function to convert floating point
number to integers.  Type conversions do not attempt to round floating
point numbers to the nearest integer.  Thus the average of `1s' and
`2s' is computed in double precisions arithmetic as (`1.0d' +
`1.5d')/2) = `1.5d'.  This result is converted to `NC_SHORT' and stored
on disk as `floor(1.5d)' = `1s' (3).  Thus no "rounding up" is
performed.  The type conversion rules of C can be stated as follows: If
N is an integer then any floating point value X satisfying

   n <= x < n+1

   will have the value N when converted to an integer.

   ---------- Footnotes ----------

   (1)

   32767 = 2^15-1

   (2) Operators began performing type conversions before arithmetic in
NCO version 1.2, August, 2000.  Previous versions never performed
unnecessary type conversion for arithmetic.

   (3) The actual type conversions are handled by intrinsic C-language
type conversion, so the `floor()' function is not explicitly called,
though the results would be the same if it were.


File: nco.info,  Node: Manual type conversion,  Prev: Automatic type conversion,  Up: Type Conversion

3.26.2 Manual type conversion
-----------------------------

`ncap2' provides intrinsic functions for performing manual type
conversions.  This, for example, converts variable `tpt' to external
type `NC_SHORT' (a C-type `short'), and variable `prs' to external type
`NC_DOUBLE' (a C-type `double').
     ncap2 -s 'tpt=short(tpt);prs=double(prs)' in.nc out.nc
   *Note ncap2 netCDF Arithmetic Processor::, for more details.


File: nco.info,  Node: Batch Mode,  Next: History Attribute,  Prev: Type Conversion,  Up: Common features

3.27 Batch Mode
===============

Availability: All operators
Short options: `-O', `-A'
Long options: `--ovr', `--overwrite', `--apn', `--append'
If the OUTPUT-FILE specified for a command is a pre-existing file, then
the operator will prompt the user whether to overwrite (erase) the
existing OUTPUT-FILE, attempt to append to it, or abort the operation.
However, interactive questions reduce productivity when processing large
amounts of data.  Therefore NCO also implements two ways to override
its own safety features, the `-O' and `-A' switches.  Specifying `-O'
tells the operator to overwrite any existing OUTPUT-FILE without
prompting the user interactively.  Specifying `-A' tells the operator
to attempt to append to any existing OUTPUT-FILE without prompting the
user interactively.  These switches are useful in batch environments
because they suppress interactive keyboard input.


File: nco.info,  Node: History Attribute,  Next: File List Attributes,  Prev: Batch Mode,  Up: Common features

3.28 History Attribute
======================

Availability: All operators
Short options: `-h'
Long options: `--hst', `--history'
All operators automatically append a `history' global attribute to any
file they create or modify.  The `history' attribute consists of a
timestamp and the full string of the invocation command to the
operator, e.g., `Mon May 26 20:10:24 1997: ncks in.nc foo.nc'.  The
full contents of an existing `history' attribute are copied from the
first INPUT-FILE to the OUTPUT-FILE.  The timestamps appear in reverse
chronological order, with the most recent timestamp appearing first in
the `history' attribute.  Since NCO and many other netCDF operators
adhere to the `history' convention, the entire data processing path of
a given netCDF file may often be deduced from examination of its
`history' attribute.  As of May, 2002, NCO is case-insensitive to the
spelling of the `history' attribute name.  Thus attributes named
`History' or `HISTORY' (which are non-standard and not recommended)
will be treated as valid history attributes.  When more than one global
attribute fits the case-insensitive search for "history", the first one
found will be used.  `history' attribute To avoid information overkill,
all operators have an optional switch (`-h', `--hst', or `--history')
to override automatically appending the `history' attribute (*note
ncatted netCDF Attribute Editor::).  Note that the `-h' switch also
turns off writing the `nco_input_file_list' attribute for multi-file
operators (*note File List Attributes::).


File: nco.info,  Node: File List Attributes,  Next: CF Conventions,  Prev: History Attribute,  Up: Common features

3.29 File List Attributes
=========================

Availability: `ncea', `ncecat', `ncra', `ncrcat'
Short options: `-H'
Long options: `--fl_lst_in', `--file_list'
Many methods of specifying large numbers of input file names pass these
names via pipes, encodings, or argument transfer programs (*note Large
Numbers of Files::).  When these methods are used, the input file list
is not explicitly passed on the command line.  This results in a loss
of information since the `history' attribute no longer contains the
exact command by which the file was created.

   NCO solves this dilemma by archiving input file list attributes.
When the input file list to a multi-file operator is specified via
`stdin', the operator, by default, attaches two global attributes to
any file they create or modify.  The `nco_input_file_number' global
attribute contains the number of input files, and `nco_input_file_list'
contains the file names, specified as standard input to the multi-file
operator.  This information helps to verify that all input files the
user thinks were piped through `stdin' actually arrived.  Without the
`nco_input_file_list' attribute, the information is lost forever and
the "chain of evidence" would be broken.

   The `-H' switch overrides (turns off) the default behavior of
writing the input file list global attributes when input is from
`stdin'.  The `-h' switch does this too, and turns off the `history'
attribute as well (*note History Attribute::).  Hence both switches
allows space-conscious users to avoid storing what may amount to many
thousands of filenames in a metadata attribute.


File: nco.info,  Node: CF Conventions,  Next: ARM Conventions,  Prev: File List Attributes,  Up: Common features

3.30 CF Conventions
===================

Availability: `ncbo', `ncea', `ncecat', `ncflint', `ncra', `ncwa'
Short options: None
NCO recognizes the Climate and Forecast (CF) metadata conventions, and
treats such data (often called history tapes), specially.  NCO handles
older NCAR model datasets, such as CCM and early CCSM datasets, with
its CF rules even though the earlier data may not contain an explicit
`Conventions' attribute (e.g., `CF-1.0').  We refer to all such data
collectively as CF data.  Skip this section if you never work with CF
data.

   The CF netCDF conventions are described at
`http://www.cgd.ucar.edu/cms/eaton/cf-metadata/CF-1.0.html'.  Most CF
netCDF conventions are transparent to NCO (1).  There are no known
pitfalls associated with using any NCO operator on files adhering to
these conventions (2).  However, to facilitate maximum user
friendliness, NCO does treat certain variables in some CF files
specially.  The special functions are not required by the CF netCDF
conventions, but experience shows they simplify data analysis.

   Currently, NCO determines whether a datafile is a CF output datafile
simply by checking whether value of the global attribute `Conventions'
(if it exists) equals `CF-1.0' or `NCAR-CSM'.  Should `Conventions'
equal either of these in the (first) INPUT-FILE, NCO will attempt to
treat certain variables specially, because of their meaning in CF files.
NCO will not average the following variables often found in CF files:
`ntrm', `ntrn', `ntrk', `ndbase', `nsbase', `nbdate', `nbsec', `mdt',
`mhisf'.  These variables contain scalar metadata such as the
resolution of the host geophysical model and it makes no sense to
change their values.

   Furthermore, the `ncbo' operator does not operate on (i.e., add,
subtract, etc.) the following variables: `ORO', `area', `datesec',
`date', `gw', `hyai', `hyam', `hybi'.  `hybm', `lat_bnds', `lon_bnds',
`msk_*'.  These variables represent the Gaussian weights, the orography
field, time fields, hybrid pressure coefficients, and
latititude/longitude boundaries.  We call these fields non-coordinate
"grid properties".  Coordinate grid properties are easy to identify
because they are coordinate variables such as `latitude' and
`longitude'.

   Users usually want _all_ grid properties to remain unaltered in the
output file.  To be treated as a grid property, the variable name must
_exactly_ match a name in the above list, or be a coordinate variable.
The handling of `msk_*' is exceptional in that _any_ variable name
beginning with the string `msk_' is considered to be a "mask" and is
thus preserved (not operated on arithmetically).

   You must spoof NCO if you would like any grid properties or other
special CF fields processed normally.  For example rename the variables
first with `ncrename', or alter the `Conventions' attribute.

   NCO supports the CF `coordinates' convention described here
(http://cf-pcmdi.llnl.gov/documents/cf-conventions/1.1/cf-conventions.html#coordinate-system).
This convention allows variables to specify additional coordinates
(including multidimensional coordinates) in a space-separated string
attribute named `coordinates'.  NCO attaches any such coordinates to
the extraction list along with variable and its usual (one-dimensional)
coordinates, if any.  These auxiliary coordinates are subject to the
user-specified overrides described in *note Subsetting Coordinate
Variables::.

   ---------- Footnotes ----------

   (1) The exception is appending/altering the attributes `x_op',
`y_op', `z_op', and `t_op' for variables which have been averaged
across space and time dimensions.  This feature is scheduled for future
inclusion in NCO.

   (2) The CF conventions recommend `time' be stored in the format TIME
since BASE_TIME, e.g., the `units' attribute of `time' might be `days
since 1992-10-8 15:15:42.5 -6:00'.  A problem with this format occurs
when using `ncrcat' to concatenate multiple files together, each with a
different BASE_TIME.  That is, any `time' values from files following
the first file to be concatenated should be corrected to the BASE_TIME
offset specified in the `units' attribute of `time' from the first file.
The analogous problem has been fixed in ARM files (*note ARM
Conventions::) and could be fixed for CF files if there is sufficient
lobbying.


File: nco.info,  Node: ARM Conventions,  Next: Operator Version,  Prev: CF Conventions,  Up: Common features

3.31 ARM Conventions
====================

Availability: `ncrcat'
Short options: None
`ncrcat' has been programmed to correctly handle data files which
utilize the Atmospheric Radiation Measurement (ARM) Program convention
(http://www.arm.gov/data/time.stm) for time and time offsets.  If you
do not work with ARM data then you may skip this section.  ARM data
files store time information in two variables, a scalar, `base_time',
and a record variable, `time_offset'.  Subtle but serious problems can
arise when these type of files are just blindly concatenated.
Therefore `ncrcat' has been specially programmed to be able to chain
together consecutive ARM INPUT-FILES and produce and an OUTPUT-FILE
which contains the correct time information.  Currently, `ncrcat'
determines whether a datafile is an ARM datafile simply by testing for
the existence of the variables `base_time', `time_offset', and the
dimension `time'.  If these are found in the INPUT-FILE then `ncrcat'
will automatically perform two non-standard, but hopefully useful,
procedures.  First, `ncrcat' will ensure that values of `time_offset'
appearing in the OUTPUT-FILE are relative to the `base_time' appearing
in the first INPUT-FILE (and presumably, though not necessarily, also
appearing in the OUTPUT-FILE).  Second, if a coordinate variable named
`time' is not found in the INPUT-FILES, then `ncrcat' automatically
creates the `time' coordinate in the OUTPUT-FILE.  The values of `time'
are defined by the ARM conventions TIME = BASE_TIME + TIME_OFFSET.
Thus, if OUTPUT-FILE contains the `time_offset' variable, it will also
contain the `time' coordinate.  A short message is added to the
`history' global attribute whenever these ARM-specific procedures are
executed.


File: nco.info,  Node: Operator Version,  Prev: ARM Conventions,  Up: Common features

3.32 Operator Version
=====================

Availability: All operators
Short options: `-r'
Long options: `--revision', `--version', or `--vrs'
All operators can be told to print their version information, library
version, copyright notice, and compile-time configuration with the `-r'
switch, or its long-option equivalent `revision'.  The `--version' or
`--vrs' switches print the operator version information only.  The
internal version number varies between operators, and indicates the
most recent change to a particular operator's source code.  This is
useful in making sure you are working with the most recent operators.
The version of NCO you are using might be, e.g., `3.9.5'.  Using `-r'
on, say, `ncks', produces something like `NCO netCDF Operators version
"3.9.5" last modified 2008/05/11 built May 12 2008 on neige by zender
Copyright (C) 1995--2008 Charlie Zender ncks version 20090918'.  This
tells you that `ncks' contains all patches up to version `3.9.5', which
dates from May 11, 2008.


File: nco.info,  Node: Operator Reference Manual,  Next: Contributing,  Prev: Common features,  Up: Top

4 Operator Reference Manual
***************************

This chapter presents reference pages for each of the operators
individually.  The operators are presented in alphabetical order.  All
valid command line switches are included in the syntax statement.
Recall that descriptions of many of these command line switches are
provided only in *note Common features::, to avoid redundancy.  Only
options specific to, or most useful with, a particular operator are
described in any detail in the sections below.

* Menu:

* ncap2 netCDF Arithmetic Processor::
* ncatted netCDF Attribute Editor::
* ncbo netCDF Binary Operator::
* ncea netCDF Ensemble Averager::
* ncecat netCDF Ensemble Concatenator::
* ncflint netCDF File Interpolator::
* ncks netCDF Kitchen Sink::
* ncpdq netCDF Permute Dimensions Quickly::
* ncra netCDF Record Averager::
* ncrcat netCDF Record Concatenator::
* ncrename netCDF Renamer::
* ncwa netCDF Weighted Averager::


File: nco.info,  Node: ncap2 netCDF Arithmetic Processor,  Next: ncatted netCDF Attribute Editor,  Prev: Operator Reference Manual,  Up: Operator Reference Manual

4.1 `ncap2' netCDF Arithmetic Processor
=======================================

`ncap2' understands a relatively full-featured language of operations,
including loops, conditionals, arrays, and math functions.  `ncap2' is
the most rapidly changing NCO operator and its documentation is
incomplete.  The distribution file `data/ncap2_tst.nco' contains an
up-to-date overview of its syntax and capabilities.  The `data/*.nco'
distribution files (especially `bin_cnt.nco', `psd_wrf.nco', and
`rgr.nco') contain in-depth examples of `ncap2' solutions to complex
problems.

SYNTAX
     ncap2 [-3] [-4] [-6] [-A] [-C] [-c] [-D DBG] [-F] [-f] [-L DFL_LVL]
     [-l PATH] [-O] [-o OUTPUT-FILE] [-p PATH] [-R] [-r]
     [-s ALGEBRA] [-S FL.NCO] [-t THR_NBR] [-v]
     INPUT-FILE [OUTPUT-FILE]

DESCRIPTION

   `ncap2' arithmetically processes netCDF files (1).  The processing
instructions are contained either in the NCO script file `fl.nco' or in
a sequence of command line arguments.  The options `-s' (or long
options `--spt' or `--script') are used for in-line scripts and `-S'
(or long options `--fl_spt' or `--script-file') are used to provide the
filename where (usually multiple) scripting commands are pre-stored.
`ncap2' was written to perform arbitrary algebraic transformations of
data and archive the results as easily as possible.  *Note Missing
Values::, for treatment of missing values.  The results of the
algebraic manipulations are called "derived fields".

   Unlike the other operators, `ncap2' does not accept a list of
variables to be operated on as an argument to `-v' (*note Subsetting
Variables::).  Rather, the `-v' switch takes no arguments and indicates
that `ncap2' should output _only_ user-defined variables.  `ncap2'
neither accepts nor understands the -X switch.

* Menu:

* Syntax of ncap2 statements::
* Expressions::
* Dimensions::
* Left hand casting::
* Arrays and hyperslabs::
* Attributes::
* Number literals::
* if statement::
* print statement::
* Missing values ncap2::
* Methods and functions::
* RAM variables::
* Where statement::
* Loops::
* Include files::
* sort methods::
* Irregular grids::
* bilinear interpolation::
* GSL special functions::
* GSL interpolation::
* GSL least-squares fitting::
* GSL statistics::
* GSL random number generation::
* Examples ncap2::
* Intrinsic mathematical methods::
* Operators precedence and associativity ::
* ID Quoting::

   Defining new variables in terms of existing variables is a powerful
feature of `ncap2'.  Derived fields inherit the metadata (i.e.,
attributes) of their ancestors, if any, in the script or input file.
When the derived field is completely new (no identically-named ancestors
exist), then it inherits the metadata (if any) of the left-most variable
on the right hand side of the defining expression.  This metadata
inheritance is called "attribute propagation".  Attribute propagation
is intended to facilitate well-documented data analysis, and we welcome
suggestions to improve this feature.

   ---------- Footnotes ----------

   (1) `ncap2' is the successor to `ncap' which was put into
maintenance mode in November, 2006.  This documentation refers to
`ncap2', which has a superset of the `ncap' functionality.  Eventually
`ncap' will be deprecated in favor `ncap2'.  `ncap2' may be renamed
`ncap' in 2010 or 2011.


File: nco.info,  Node: Syntax of ncap2 statements,  Next: Expressions,  Prev: ncap2 netCDF Arithmetic Processor,  Up: ncap2 netCDF Arithmetic Processor

4.1.1 Syntax of `ncap2' statements
----------------------------------

Mastering `ncap2' is relatively simple.  Each valid statement STATEMENT
consists of standard forward algebraic expression.  The `fl.nco', if
present, is simply a list of such statements, whitespace, and comments.  The
syntax of statements is most like the computer language C.  The
following characteristics of C are preserved:
Array syntax
     Arrays elements are placed within `[]' characters;

Array indexing
     Arrays are 0-based;

Array storage
     Last dimension is most rapidly varying;

Assignment statements
     A semi-colon `;' indicates the end of an assignment statement.

Comments
     Multi-line comments are enclosed within `/* */' characters.
     Single line comments are preceded by `//' characters.

Nesting
     Files may be nested in scripts using `#include SCRIPT'.  Note that
     the `#include' command is not followed by a semi-colon because it
     is a pre-processor directive, not an assignment statement.  The
     filename `script' is interpreted relative to the run directory.

Attribute syntax
     The at-sign `@' is used to delineate an attribute name from a
     variable name.


File: nco.info,  Node: Expressions,  Next: Dimensions,  Prev: Syntax of ncap2 statements,  Up: ncap2 netCDF Arithmetic Processor

4.1.2 Expressions
-----------------

Expressions are the fundamental building block of `ncap2'.  Expressions
are composed of variables, numbers, literals, and attributes.  The
following C operators are "overloaded" and work with scalars and
multi-dimensional arrays:
     Arithmetic Operators: * / % + - ^
     Binary Operators:     > >= < <= == != == || && >> <<
     Unary Operators:      + - ++ -- !
     Conditional Operator: exp1 ? exp2 : exp3
     Assign Operators:     = += -= /= *=

   In the following section a "variable" also refers to a number
literal which is read in as a scalar variable:

   *Arithmetic and Binary Operators *

   Consider _var1 'op' var2_

   *Precision*
   * When both operands are variables, the result has the precision of
     the higher precision operand

   * When one operand is a variable and the other an attribute, the
     result has the precision of the variable.

   * When both operands are attributes, the result has the precision of
     the more precise attribute.

   * The exponentiation operator "^" is an exception to the above rules.
     When both operands have type less than `NC_FLOAT', the result is
     `NC_FLOAT'.  When either type is `NC_DOUBLE', the result is also
     `NC_DOUBLE'.

   *Rank*


   * The Rank of the result is generally equal to Rank of the operand
     that has the greatest number of dimensions.

   * If the dimensions in var2 are a subset of the dimensions in var1
     then its possible to  make var2 conform to var1 through
     broadcasting and or dimension reordering.

   * Broadcasting a variable means creating data in non-existing
     dimensions from the data in existing dimensions.

   * More specifically: If the numbers of dimensions in var1 is greater
     than or equal to the number of dimensions in var2 then an attempt
     is made to make var2 conform to var1 ,else var1 is made to conform
     to var2. If conformance  is not possible then an error message
     will be emitted and script execution will cease.

Even though the logical operators return True(1) or False(0) they are
treated in the same way as the arithmetic operators with regard to
precision and rank.
examples:

     dimensions: time=10, lat=2, lon=4
     Suppose we have the two variables:

     double  P(time,lat,lon);
     float   PZ0(lon,lat);  // PZ0=1,2,3,4,5,6,7,8;

     Consider now the expression:
      PZ=P-PZ0

     PZ0 is made to conform to P and the result is
     PZ0 =
        1,3,5,7,2,4,6,8,
        1,3,5,7,2,4,6,8,
        1,3,5,7,2,4,6,8,
        1,3,5,7,2,4,6,8,
        1,3,5,7,2,4,6,8,
        1,3,5,7,2,4,6,8,
        1,3,5,7,2,4,6,8,
        1,3,5,7,2,4,6,8,
        1,3,5,7,2,4,6,8,
        1,3,5,7,2,4,6,8,

     Once the expression is evaluated then PZ will be of type double;

     Consider now
      start=four-att_var@double_att;  // start =-69  and is of type intger;
      four_pow=four^3.0f               // four_pow=64 and is of type float
      three_nw=three_dmn_var_sht*1.0f; // type is now float
      start@n1=att_var@short_att*att_var@int_att;
                                       // start@n1=5329 and is type int

*Binary Operators*
Unlike C the binary operators return an array of values. There is no
such thing as short circuiting  with the AND/OR operators. Missing
values are carried into the result in the same way they are with the
arithmetic operators. When an expression is evaluated in an if() the
missing values are treated as true.
The Binary operators are,in order of precedence:


     !   Logical Not
     ----------------------------
     <<  Less Than Selection
     >>  Greater Than Selection
     ----------------------------
     >   Greater than
     >=  Greater than or equal to
     <   Less than
     <=  Less than or equal to
     ----------------------------
     ==  Equal to
     !=  Not equal to
     ----------------------------
     &&  Logical AND
     ----------------------------
     ||  Logical OR
     ----------------------------

   To see all operators: *note Operators precedence and associativity::

   examples:

     tm1= time>2 && time <7;  // tm1 = 0, 0, 1, 1, 1, 1, 0, 0, 0, 0 ; type double;
     tm2= time==3 || time>=6; // tm2 = 0, 0, 1, 0, 0, 1, 1, 1, 1, 1 ; type double
     tm3= int(!tm1);          // tm3=  1, 1, 0, 0, 0, 0, 1, 1, 1, 1 ; type int
     tm4= tm1 && tm2;         // tm4=  0, 0, 1, 0, 0, 1, 0, 0, 0, 0 ; type double;
     tm5= !tm4;               // tm5=  1, 1, 0, 1, 1, 0, 1, 1, 1, 1 ; type double;

*Regular Assign Operator*
_var1 '=' exp1_
If var1 doesn't already exist in Output then var1 is written to Output
with the values and dimensions from expr1. If var1 already exists in
Output, then the only requirement on expr1 is that the number of
elements must match the number already on disk. The type of expr1 is
converted if necessary to the disk type.

* Other Assign Operators +=,-=,*=./= *
_var1 'ass_op' exp1 _
if exp1 is a variable and it doesn't conform to var1 then an attempt is
made to make it conform to var1. If exp1 is an attribute it must have
unity size or else have the same number of elements as var1. If expr1
has a different type to var1 the it is converted to the var1 type.

   example:

     z1=four+=one*=10 // z1=14 four=14 one=10;
     time-=2          // time= -1,0,1,2,3,4,5,6,7,8

*Increment/ Decrement Operators
* These work in a similar fashion to their regular C counterparts. If
say the variable "four" is input only then the statement "++four"
effectively means -read four from input increment each element by one ,
then write the new values to Output;

   example:

     n2=++four;   n2=5, four=5
     n3=one--+20; n3=21  one=0;
     n4=--time;   n4=time=0.,1.,2.,3.,4.,5.,6.,7.,8.,9.;

*Conditional Operator ?: *
_exp1 ? exp2 : exp3 _
The conditional operator ( or ternary Operator) is nice and succinct
way of writing an if/then/else. If exp1 evaluates to true then exp2 is
returned else exp3 is returned.

   example
     weight_avg= weight.avg();
     weight_avg@units= (weight_avg ==1 ? "kilo" : "kilos");

     PS_nw= PS - (PS.min() >100000 ? 100000 : 0 );

*Clipping Operators* 
<< Less Than Selection
     For arrays, the less-than selection operator selects all values in
     the left operand that are less than the corresponding value in the
     right operand. If the value of the left side is greater than or
     equal to the corresponding value of the right side, then the right
     side value is placed in the result

>> Greater Than Selection
     For arrays, the greater-than selection operator selects all values
     in the left operand that are greater than the corresponding value
     in the right operand. If the value of the left side is less than
     or equal to the corresponding value of the right side, then the
     right side value is placed in the result.

   example:

     RDM2= RDM >>100.0;   RDM2=100,100,100,100,126,126,100,100,100, 100 ;  // type double
     RDM2= RDM <<90s;     RDM3=1, 9, 36, 84, 90, 90, 84, 36, 9, 1 ;        // type int


File: nco.info,  Node: Dimensions,  Next: Left hand casting,  Prev: Expressions,  Up: ncap2 netCDF Arithmetic Processor

4.1.3 Dimensions
----------------

Dimensions can be defined in Output using the `defdim()' function.
     defdim("cnt",10);

   This dimension can then be subsequently referred to in method
arguments and a left hand cast by prefixing it with a dollar e.g
     new_var[$cnt]=time;
     temperature[$time,$lat,$lon]=35.5;
     temp_avg=temperature.avg($time);

   To refer to the dimension size in an expression use the `size'
method.
     time_avg=time.total() / $time.size;

   Increase size of new var by one and set new member to zero;
     defdim("cnt_grw", $cnt.size+1);
     new_var_grw[$cnt_grw]=0.0;
     new_var_grw( 0:($cnt_grw.size-2))=new_var;

*Dimension Abbreviations
* Its possible to use dimension abbreviations as method arguments.
`$0' is the first dimension of the variable
`$1' is the second dimension of the variable
`$n' is the n+1 dimension of the variable
consider the variables:
     float four_dmn_rec_var(time,lat,lev,lon);
     double three_dmn_var_dbl(time,lat,lon);

     four_nw=four_dmn_rev_var.reverse($time,$lon)
     four_nw=four_dmn_rec_var.reverse($0,$3);

     four_avg=four_dmn_rec_var.avg($lat,$lev);
     four_avg=four_dmn_rec_var.avg($1,$2);

     three_mw=three_dmn_var_dbl.permute($time,$lon,$lat);
     three_mw=three_dmn_var_dbl.permute($0,$2,$1);

*ID Quoting
* If the dim name contains non-regular characters use ID quoting. See
*note ID Quoting::
     defdim("a--list.A",10);
     A1['$a--list.A']=30.0;

*GOTCHA
* It is not possible to manually define in Output any dimensions that
exist in Input. When a variable from Input appears in an expression or
statement its  dimensions in Input are  automagically copied to Output
(if they are not already present)


File: nco.info,  Node: Left hand casting,  Next: Arrays and hyperslabs,  Prev: Dimensions,  Up: ncap2 netCDF Arithmetic Processor

4.1.4 Left hand casting
-----------------------

The following examples demonstrate the utility of the "left hand
casting" ability of `ncap2'.  Consider first this simple, artificial,
example.  If LAT and LON are one dimensional coordinates of dimensions
LAT and LON, respectively, then addition of these two one-dimensional
arrays is intrinsically ill-defined because whether LAT_LON should be
dimensioned LAT by LON or LON by LAT is ambiguous (assuming that
addition is to remain a "commutative" procedure, i.e., one that does
not depend on the order of its arguments).  Differing dimensions are
said to be "orthogonal" to one another, and sets of dimensions which
are mutually exclusive are orthogonal as a set and any arithmetic
operation between variables in orthogonal dimensional spaces is
ambiguous without further information.

   The ambiguity may be resolved by enumerating the desired dimension
ordering of the output expression inside square brackets on the left
hand side (LHS) of the equals sign.  This is called "left hand casting"
because the user resolves the dimensional ordering of the RHS of the
expression by specifying the desired ordering on the LHS.
     ncap2 -s 'lat_lon[lat,lon]=lat+lon' in.nc out.nc
     ncap2 -s 'lon_lat[lon,lat]=lat+lon' in.nc out.nc
   The explicit list of dimensions on the LHS, `[lat,lon]' resolves the
otherwise ambiguous ordering of dimensions in LAT_LON.  In effect, the
LHS "casts" its rank properties onto the RHS.  Without LHS casting, the
dimensional ordering of LAT_LON would be undefined and, hopefully,
`ncap2' would print an error message.

   Consider now a slightly more complex example.  In geophysical
models, a coordinate system based on a blend of terrain-following and
density-following surfaces is called a "hybrid coordinate system".  In
this coordinate system, four variables must be manipulated to obtain
the pressure of the vertical coordinate: PO is the domain-mean surface
pressure offset (a scalar), PS is the local (time-varying) surface
pressure (usually two horizontal spatial dimensions, i.e. latitude by
longitude), HYAM is the weight given to surfaces of constant density
(one spatial dimension, pressure, which is orthogonal to the horizontal
dimensions), and HYBM is the weight given to surfaces of constant
elevation (also one spatial dimension).  This command constructs a
four-dimensional pressure `prs_mdp' from the four input variables of
mixed rank and orthogonality:
     ncap2 -s 'prs_mdp[time,lat,lon,lev]=P0*hyam+PS*hybm' in.nc out.nc
   Manipulating the four fields which define the pressure in a hybrid
coordinate system is easy with left hand casting.


File: nco.info,  Node: Arrays and hyperslabs,  Next: Attributes,  Prev: Left hand casting,  Up: ncap2 netCDF Arithmetic Processor

4.1.5 Arrays and hyperslabs
---------------------------

Hyperslabs in `ncap2' are a bit more limited than  hyperslabs with the
other nco operators.  There is no per-se multi-slabs, wrapped
co-ordinates, negative stride or co-ordinate value limits. However with
a bit of syntactic magic they are all are possible.
       var1( hyper_arg1, hyper_arg2 .. hyper_argN)
   A hyperslab argument is specified using the following notation

     start:end:stride

if "start" is omitted - then default = 0
if "end" is omitted - default = dimension size less one
if "stride" is omitted - default = 1

If a single value is present then it is assumed that that dimension
collapses to a single value (ie a cross-section). The number of
hyperslab arguments MUST be equal to the number of dimensions of the
variable.

*Hyperslabs on the Right Hand Side of an assign
*

   A simple 1D example:

     ($time.size=10)
     od[$time]={20,22,24,26,28,30,32,34,36,38};

     od(7);     // 34
     od(7:);    // 34,36,38
     od(:7);    // 20, 22, 24, 26, 28, 30, 32, 34
     od(::4);   // 20.28,36
     od(1:6:2)  //  22,26,30
     od(:)      //  20,22,24,26,28,30,32,34,36,38

   A more complex 3D example

     ($lat.size=2, $lon.size=4 )
     th[$time,$lat,$lon]=
                               {1, 2, 3, 4, 5, 6, 7, 8,
                               9,10,11,12,13,14,15,16,
                               17,18,19,20,21,22,23,24,
                               -99,-99,-99,-99,-99,-99,-99,-99,
                               33,34,35,36,37,38,39,40,
                               41,42,43,44,45,46,47,48,
                               49,50,51,52,53,54,55,56,
                               -99,58,59,60,61,62,63,64,
                               65,66,67,68,69,70,71,72,
                               -99,74,75,76,77,78,79,-99 };

     th(1,1,3);        // 16
     th(2,0,:);        // { 17, 18, 19, 20 };
     th(:,1,3);        // 8, 16, 24, -99, 40, 48, 56, 64, 72, -99
     th(::5 ,:,0:3:2); // 1, 3, 5, 7, 41, 43, 45, 47 ;

   If any of the hyperslab arguments collapse to a single value ( a
cross-section has been specified), then that dimension is removed from
the returned variable. If all the values collapse then a scalar
variable is returned

   So for example: the following is valid:

     th_nw=th(0,:,:) +th(9,:,:);
     th_nw  has dimensions $lon,$lat
     nb the time dim has become degenerate

   The following is not valid:
     th_nw=th(0,:,0:1) +th(9,:,0:1);

   As the _$lon_ now only has two elements.  The above can be
calculated by using a LHS cast with _$lon_nw_ as replacement dim for
_$lon_.
     defdim("lon_nw",2);
     th_nw[$lat,$lon_nw]=th(0,:,0:1) +th(9,:,0:1);

*Hyperslabs on the Left Hand Side of an assign
* When hyperslabing on the LHS ,the expression on the RHS must evaluate
to a scalar or a variable/attribute with the same number of elements as
the LHS hyperslab

   Sets all elements of the last record to zero.
     th(9,:,:)=0.0;

   Set first element of each lon element to 1.0.
     th(:,:,0)=1.0;

   Can hyperslab on both sides of an assign.
Sets the last record to the same as the first record
     th(9,:,:)=th(0,:,:);

   th0 represents pressure at height=0
th1 represents pressure at height=1
Then its possible to hyperslab in the records
     P[$time,$height,$lat,$lon]=0.0;
     P(:,0,:,:)=th0;
     P(:,1,:,:)=th1

*Reverse method*
If you want to reverse a dimension's elements in an variable use the
`reverse()' method with at least one dimension argument (this is
equivalent to applying a negative stride) e.g
     th_rv=th(1 ,:,:).reverse($lon); // { 12,11,10,9 } ,{16,15,14,13 }
     od_rv=od.reverse($time);        // {38, 36, 34, 32, 30, 28, 26, 24, 22, 20 }

*Permute method*
If you want to swap about the dimensions of a variable use the the
`permute()' method. The number and names of  dimension arguments must
match the dimensions in the variable. If the first dimension  in the
variable is of record type then this must remain the first dimension.
If you want to change the record dimension consider using `ncpdq' .

   Consider the variable:
     float three_dmn_var(lat,lev,lon);

     three_dmn_var_pm=three_dmn_var.permute($lon,$lat,$lev);

     three_dmn_var_pm=
       0,4,8,
       12,16,20,
       1,5,9,
       13,17,21,
       2,6,10,
       14,18,22,
       3,7,11,
       15,19,23;


File: nco.info,  Node: Attributes,  Next: Number literals,  Prev: Arrays and hyperslabs,  Up: ncap2 netCDF Arithmetic Processor

4.1.6 Attributes
----------------

Attributes are referred to by _var_nm@att_nm_
All the following are valid statements

     global@text="Test Attributes";  /* Assign a global variable attribute */
     a1[$time]=time*20;
     a1@long_name="Kelvin";
     a1@min=a1.min();
     a1@max=a1.max();
     a1@min++;
     --a1@max; q
     a1(0)=a1@min;
     a1($time.size-1)=a1@max;

   A _value list_ can be used on the RHS of an assign...  
     a1@trip1={ 1,2,3 } ;
     a1@triplet={ a1@min, (a1@min+a1@max)/2, a1@max };

   The netcdf specification allows all attribute types to have a size
greater than one. The maximum is defined by `NC_MAX_ATTRS' -The
following is an ncdump of the meta-data for variable a1

     double a1(time) ;
       a1:long_name = "Kelvin" ;
       a1:max = 199. ;
       a1:min = 21. ;
       a1:trip1 = 1, 2, 3 ;
       a1:triplet = 21., 110., 199. ;

   The `size()' method can be used with attributes -for example to save
an attribute text string in a variable..
     defdim("sng_len", a1@long_name.size());
     sng_arr[$sng_len]=a1@long_name;         // sng_arr now contains "Kelvin"

   Attributes defined in a script are stored in memory and are written
to Output after script completion.  To stop the attribute being
written use the ram_delete() method or use a bogus variable name

*Attribute Propagation & Inheritance* 
   * Attribute propagation occurs in a regular  assign statement. The
     variable being defined on the LHS gets copies of the attributes
     from the leftermost variable on the RHS

   * Attribute Inheritance: The LHS variable "inherits" attributes from
     an Input variable with the same name

   * It is possible to have a regular assign statement for which both
     propagation and inheritance occur.

     prs_mdp[time,lat,lon,lev]=P0*hyam+hybm*PS;      //prs_mdp get attributes from PO
     th_min=1.0 + 2*three_dmn_var_dbl.min($time);    //th_min get attributes from three_dmn_var_dbl

   If the attribute name contains non-regular characters use ID
quoting. See *note ID Quoting::
     'b..m1@c--lost'=23;


File: nco.info,  Node: Number literals,  Next: if statement,  Prev: Attributes,  Up: ncap2 netCDF Arithmetic Processor

4.1.7 Number literals
---------------------

The table below lists the postfix character(s) to add to a number
literal for type cohesion. To use the new netcdf4 types nco must be
compiled/linked to the netcdf4 library and the Output file must be hdf5.

     n1[$time]=1UL;   // n1 will now by type `NC_UINT'
     n2[$lon]=4b;     // n2 will be of type `NC_BYTE'
     n3[$lat]=5ull;   // n3 will be of type `NC_UINT64'
     n3@a1=6.0d;      // attribute will be type `NC_DOUBLE'
     n3@a2=-666L;     // attribute will be type `NC_INT'

   A floating point number without a postfix will default to
`NC_DOUBLE'. An integer without a postfix will default to type
`NC_INT'. Thre is no postfix for characters. Use a quoted string.

     n4[$rlev]=.1      // n4 will be of type `NC_DOUBLE'
     n5[$lon_grd]=2.   // n5 will be of type `NC_DOUBLE'
     n6[$gds_crd]=2e3; // n6 will be of type `NC_DOUBLE'
     n6@a1=41;         // attribute will be type `NC_INT'
     n6@a2=-21;        // attribute will be type `NC_INT'
     n6@units="kelvin" // attribute will be type `NC_CHAR'


     *netCDF3/4 Types*

b|B
     `NC_BYTE'  a signed 1 byte integer

none
     `NC_CHAR'  a ISO/ASCII character

s|S
     `NC_SHORT' a signed 2 byte integer

l|L
     `NC_INT'   a signed 4 byte integer

f|F
     `NC_FLOAT' a single precision floating point number

d|D
     `NC_DOUBLE' a double precision floating point number



     *netCDF4 Types*

ub|UB
     `NC_UBYTE' a unsigned 1 byte int

us|US
     `NC_USHORT' a unsigned 2-byte int

u|U|ul|UL
     `NC_UINT' a unsigned 4-byte int

ll|LL
     `NC_INT64' a signed 8-byte int

ull|ULL
     `NC_UINT64' a unsigned 8-byte int


File: nco.info,  Node: if statement,  Next: print statement,  Prev: Number literals,  Up: ncap2 netCDF Arithmetic Processor

4.1.8 if statement
------------------

The synatax of the if statement is similar to its C counterpart. The
_Conditional Operator (ternary operator)_ has also been implemented.


     if(exp1)
        stmt1;
     else if(exp2)
        stmt2
     else
        stmt3

     Can use code blocks as well

     if(exp1){
        stmt1;
        stmt1a;
        stmt1b;
     } else if(exp2)
        stmt2
     else {
        stmt3;
        stmt3a;
        stmt3b;
     }

For a variable or attribute expression to be logically true all its
non-missing value elements must be logically true. (i.e non-zero). The
expression can be of any type. Unlike C there is no short-circuiting of
an expression with the OR (||) AND (&&) operators. The whole expression
is evaluated regardless if one of the AND/OR operands are true/false.

     A simple example

     if(time>0)
       print("All values of time are greater than zero\n");
     else if( time<0)
       print("All values of time are less than zero\n");
     else {
       time_max=time.max();
       time_min=time.min();
       print("min value of time=");print(time_min,"%f");
       print("max value of time=");print(time_max,"%f");
     }

     A real example from ddra.nco

     if(fl_typ==fl_typ_gcm){
       var_nbr_apx=32;
       lmn_nbr=1.0*var_nbr_apx*varsz_gcm_4D; /* [nbr] Variable size */
       if(nco_op_typ==nco_op_typ_avg){
         lmn_nbr_avg=1.0*var_nbr_apx*varsz_gcm_4D; /* [nbr] Averaging block size */
         lmn_nbr_wgt=dmnsz_gcm_lat; /* [nbr] Weight size */
       } // !nco_op_typ_avg
     }else if(fl_typ==fl_typ_stl){
       var_nbr_apx=8;
       lmn_nbr=1.0*var_nbr_apx*varsz_stl_2D; /* [nbr] Variable size */
       if(nco_op_typ==nco_op_typ_avg){
         lmn_nbr_avg=1.0*var_nbr_apx*varsz_stl_2D; /* [nbr] Averaging block size */
         lmn_nbr_wgt=dmnsz_stl_lat; /* [nbr] Weight size */
       } // !nco_op_typ_avg
     } // !fl_typ

*Conditional Operator
*
     // nb you need netCDF4 to run this example
     th_nw=(three_dmn_var_sht >= 0 ? three_dmn_var_sht.uint(): three_dmn_var_sht.int() );


File: nco.info,  Node: print statement,  Next: Missing values ncap2,  Prev: if statement,  Up: ncap2 netCDF Arithmetic Processor

4.1.9 print statement
---------------------

     print( variable_name/attribute name/string, format string);

The print function takes a variable name or attribute name or a quoted
string and prints the contents in a in a similar fashion to `ncks -H '.
There is also an optional C style format string argument.  Currently
the print function can't print RAM variables or expressions e.g
`'print(var_msk*3+4)'' is invalid. So if you want to print an
expression first assign a variable with the expression; then print the
variable.

examples
     print(lon);
     lon[0]=0
     lon[1]=90
     lon[2]=180
     lon[3]=270

     print(lon_2D_rrg,"%3.2f,");
     0.00,0.00,180.00,0.00,180.00,0.00,180.00,0.00,

     print(mss_val_fst@_FillValue);
     mss_val_fst@_FillValue, size = 1 NC_FLOAT, value = -999

     print("This function \t is monotonic\n");
     This function is 	  monotonic


File: nco.info,  Node: Missing values ncap2,  Next: Methods and functions,  Prev: print statement,  Up: ncap2 netCDF Arithmetic Processor

4.1.10 Missing values ncap2
---------------------------

Missing values operate slightly differently in `ncap2' Consider the
expression where op is any of the following operators (excluding '=')

     Arithmetic operators ( * / % + - ^ )
     Binary Operators     ( >, >= <, <= ==, !=,==,||,&&, >>,<< )
     Assign Operators     ( +=,-=,/=, *= )

     var1 'op' var2

if var1 has a missing value then this is the value used in the
operation else the missing value for var2 is used. if during the
element by element operation an element from either operand is equal to
the missing value then the missing value is carried through. In this
way missing values 'percolate' through an expression.
Missing values associated with Output variables are stored in memory
and are written to disk after the script finishes. During script
execution its possible (and legal) for the missing value of a variable
to take on  several different values.

     Consider the variable:
     int rec_var_int_mss_val_int(time); =-999,2,3,4,5,6,7,8,-999,-999;
     rec_var_int_mss_val_int:_FillValue = -999;

     n2=rec_var_int_mss_val_int + rec_var_int_mss_val_int.reverse($time);

     n2=-999,-999,11,11,11,11,11,11,999,-999;

   The following methods are used to edit the missing value associated
with a variable. They only work on variables in Output.

`set_miss(expr)'
     Takes one argument the missing value. Sets or overwrites the
     existing missing value. The argument given is converted if
     necessary to the variable type

`change_miss(expr)'
     Changes the missing value elements of the variable to the new
     missing value (nb an expensive function).

`get_miss()'
     Returns the missing value of a variable. If the variable exists in
     Input and Output then the missing value of the variable in Output
     is returned. If the variable has no missing value then an error is
     returned.

`delete_miss()'
     Deletes the missing value associated with a variable.


     th=three_dmn_var_dbl;
     th.change_miss(-1e10d);
     /* set values less than 0 or greater than 50 to missing value */
     where( th <0.0 || th > 50.0)
       th=th.get_miss();


     Another example

     new[$time,$lat,$lon]=1.0;
     new.set_miss(-997.0);

     /* extract only elements divisible by 3 */
     where ( three_dmn_var_dbl%3 == 0 )
          new=three_dmn_var_dbl;
     elsewhere
          new=new.get_miss();


File: nco.info,  Node: Methods and functions,  Next: RAM variables,  Prev: Missing values ncap2,  Up: ncap2 netCDF Arithmetic Processor

4.1.11 Methods and functions
----------------------------

The convention within this document is that methods can be used as
functions.  However, functions are not and cannot be used as methods.
Methods can be daisy changed together and their synatax is cleaner than
functions.  Method names are reserved words and CANNOT be used as
variable names.  The command `ncap2 -f' shows the complete list of
methods available on your build.

     n2=sin(theta) or n2=theta.sin()
     n2=sin(theta)^2 +cos(theta)^2 or  n2=theta.sin().pow(2) + theta.cos()^2

   The below statement converts three_dmn_var_sht to type double, finds
the average, then converts this average back to type short.
     three_avg=three_dmn_var_sht.double().avg().short();


* Aggregate Methods
* These methods mirror the averaging types available in `ncwa'. The
arguments to the methods are the dimensions to average over. Specifying
no dimensions is equivalent to specifying all dimensions i.e.
averaging over all dimensions. A masking variable and a weighting
variable can be manually created and applied as needed.

`avg()'
     Mean value

`sqravg()'
     Square of the mean

`avgsqr()'
     Mean of sum of squares

`max()'
     Maximum value

`min()'
     Minimum value

`rms()'
     Root-mean-square (normalized by N)

`rmssdn()'
     Root-mean square (normalized by N-1)

`ttl() or total()'
     Sum of values

     // Average a variable over time
     four_time_avg=four_dmn_rec_var($time);


* Packing Methods
* For more information see *note Packed data:: and *note ncpdq netCDF
Permute Dimensions Quickly::
`pack() & pack_short()'
     The default packing algorithm is applied and variable is packed to
     `NC_SHORT'

`pack_byte()'
     Variable is packed to `NC_BYTE'

`pack_short()'
     Variable is packed to `NC_SHORT'

`pack_int()'
     Variable is packed to `NC_INT'

`unpack()'
     The standard unpacking algorithm is applied.

*Basic Methods
* These methods work with variables and attributes. They have no
arguments

`size()'
     Total number of elements

`ndims()'
     Number of dimensions in variable

`type()'
     Returns the netcdf type (see previous section)


*Utility Methods
* These functions are used to manipulate missing values and RAM
variables.  *note Missing values ncap2::

`set_miss(expr)'
     Takes one argument the missing value. Sets or overwrites the
     existing missing value. The argument given is converted if
     necessary to the variable type

`change_miss(expr)'
     Changes the missing value elements of the variable to the new
     missing value (n.b. an expensive function).

`get_miss()'
     Returns the missing value of a variable in Input or Output

`delete_miss()'
     Deletes the missing value associated with a variable.

`ram_write()'
     Writes a RAM variable to disk i.e. converts it to a regular disk
     type variable

`ram_delete()'
     Deletes a RAM variable or an attribute


*PDQ Methods
* See *note ncpdq netCDF Permute Dimensions Quickly::
`reverse(dim args)'
     Reverses the dimension ordering of elements in a variable.

`permute(dim args)'
     Re-shapes variables by re-ordering the dimensions. All the dims of
     the variable must be specified in the arguments. A limitation of
     this permute (unlike ncpdq) is that the record dimension cannot be
     re-assigned.
   // Swap dimensions about and reorder along lon
     lat_2D_rrg_new=lat_2D_rrg.permute($lon,$lat).reverse($lon);
     lat_2D_rrg_new=0,90,-30,30,-30,30,-90,0


*Type Conversion Methods
* These methods allow `ncap2' to convert variables and attributes to
the different netcdf types. For more details on automatic and manual
type conversion see (*note Type Conversion::). You can only use the new
netcdf4 types if you have compiled/links nco with the netcdf4 library
and the Output file is hdf5.

`'
     *netCDF3/4 Types*

`byte()'
     convert to `NC_BYTE'  a signed 1 byte integer

`char()'
     convert to `NC_CHAR'  a ISO/ASCII character

`short()'
     convert to `NC_SHORT' a signed 2 byte integer

`int()'
     convert to `NC_INT'   a signed 4 byte integer

`float()'
     convert to `NC_FLOAT' a single precision floating point number

`double()'
     convert to `NC_DOUBLE' a double precision floating point number

`'

`'
     *netCDF4 Types*

`ubyte()'
     convert to `NC_UBYTE' a unsigned 1 byte int

`ushort()'
     convert to `NC_USHORT' a unsigned 2-byte int

`uint()'
     convert to `NC_UINT' a unsigned 4-byte int

`int64()'
     convert to `NC_INT64' a signed 8-byte int

`uint64()'
     convert to `NC_UINT64' a unsigned 8-byte int *

*Intrinsic Mathematical Methods
* The list of mathematical methods is system dependant.  For the full
list *note Intrinsic mathematical methods::

   All the mathematical methods take a single operand ,with the
exception of `atan2' and `pow' which take two.  If the operand type is
less than _float_ then the result will be of type _float_. If the
operand is type _double_ then the result will be type _double_. Like
the other methods, you are free to use the mathematical methods as
functions.

     n1=pow(2,3.0f)    // n1 type float
     n2=atan2(2,3.0)   // n2 type double
     n3=1/(three_dmn_var_dbl.cos().pow(2))-tan(three_dmn_var_dbl)^2; // n3 type double


File: nco.info,  Node: RAM variables,  Next: Where statement,  Prev: Methods and functions,  Up: ncap2 netCDF Arithmetic Processor

4.1.12 RAM variables
--------------------

RAM variables are used in place of regular variables to speed things
up. For example in a loop or where a variable is very frequently
referenced. To declare and define a RAM variable simply prefix the
variable name with * when the variable is declared/initialized.
To delete a RAM variable (recover some memory) use  the ram_delete()
method. To convert a RAM variable to a regular disk variable in output
use ram_write() method.
The following is valid:

     *temp[$time,$lat,lon]=10.0;     // Cast
     *temp_avg=temp.avg($time);      // Regular assign
     ....
     temp.ram_delete();              // Delete RAM variable
     temp_avg.ram_write();           // Write Variable to output

   Other Assigns

     // Create a RAM variable from the variable "one" in Input and increment its elements
     *one++;

     // Create a RAM variable from the variable three in Input and multiply its contents by 10
     // Create a RAM variable from the variable four in Input and then add the variable "three" to
     // its contents.
     *four+=*three*=10;   // three=30, four=34


File: nco.info,  Node: Where statement,  Next: Loops,  Prev: RAM variables,  Up: ncap2 netCDF Arithmetic Processor

4.1.13 Where statement
----------------------

A `where()' combines the definition and application of a mask all in
one go and can lead to succinct code.  The full syntax of a `where()'
statement is as follows:

     // Single assign (nb the else block is optional)
     where (mask)
        var1=expr1;
     elsewhere
        var1=expr2;


     // Multiple assigns
     where( mask) {
         var1=expr1;
         var2=expr2;
         ...
         } elsewhere {
         var1=expr3
         var2=expr4
         var3=expr5;
         ...
         }

   * The only expression allowed within a where is the assign
     'var=expr'. This is different from a regular `ncap2' assign. The
     LHS var must already exist in Input or Output. The expression on
     the RHS must evaluate to a scalar or a variable/attribute of the
     same size as the LHS variable.

   * Taking the general case of a variable on the LHS side and RHS. For
     every element of the mask which is True , the corresponding LHS
     variable element  is re-assigned with its partner element on the
     RHS. In the elsewhere part the mask is logically inverted and the
     assign process continues

   * if the mask dimensions are a subset of the LHS variable's
     dimensions , then it is made to conform; if it  can't be made to
     conform then script execution halts.

   * Missing values in the mask evaluate to False in the  first
     code/block statement and True in the elsewhere block/statement.
     LHS variable elements set to missing value are not re-assigned


   example:

   Consider the variables:
`float lon_2D_rct(lat,lon);
' `float var_msk(lat,lon);
' Suppose we want to multiply by two the elements for which var_msk is
equal to 1;

     where(var_msk==1)
       lon_2D_rct=2*lon_2D_rct;

   Another example
Suppose we have the variable
`int RDM(time);'
And we want to set the values less than 8 or greater than 80 to 0.
     where(RDM <8 || RDM >80)
       RDM=0;

A more complex example.
Consider the situation where we have irregularly gridded data,
described using rank 2 variables:
` double lat(south_north,east_west)
double lon(south_north,east_west)
double temperature(south_north,east west)
' To find the average temperature in a region [lat_min,lat_max] and
[lon_min,lon_max]:


     temperature_msk[$south_north,$east_west]=0.0;

     where(lat >= lat_min && lat <= lat_max) && (lon >= lon_min && > lon <= lon_max)
       temperature_msk=temperature;
     elsewhere
       temperature_msk=temperature@_FillValue;

     temp_avg=temperature_msk.avg();
     temp_max=temperature.max();


File: nco.info,  Node: Loops,  Next: Include files,  Prev: Where statement,  Up: ncap2 netCDF Arithmetic Processor

4.1.14 Loops
------------

In `ncap' there are for() loops and while() loops. They are currently
completely unoptimized So use them with  RAM variables unless you want
thrash your disk to death. To break out of a loop use "break" command.
To iterate to the next cycle use the "continue" command.

     // Follwing sets elements in variable double temp(time,lat)
     // If element < 0 set to 0, if element >100 set to 100

     *sz_idx=$time.size;
     *sz_jdx=$lat.size;

       for(*idx=0 ; idx<sz_idx ; idx++)
        for(*jdx=0 ; jdx<sz_jdx; jdx++)
         if(  temp(idx,jdx) >100 ) temp(idx,jdx)=100.0;
         else if(  temp(idx,jdx) <0 ) temp(idx,jdx)=0.0;

     // See if values of of a co-ordinate variable double lat(lat) are monotonic
     *sz=$lat.size;

        for(*idx=1 ; idx<sz;idx++)
          if( lat(idx)-lat(idx-1) < 0.0)
     	break;

        if(idx==sz)
          print("lat co-ordinate is monotonic\n");
        else
          print("lat co-ordinate is NOT monotonic\n");

     // Sum odd elements
     *idx=0;
     *sz=$lat_nw.size;
     *sum=0.0;
       while(idx<sz){
        if( lat(idx) % 2) sum+=lat(idx);
        idx++;
       }

     ram_write(sum);
     print("Total of odd elements ");print(sum);print("\n");


File: nco.info,  Node: Include files,  Next: sort methods,  Prev: Loops,  Up: ncap2 netCDF Arithmetic Processor

4.1.15 Include files
--------------------

The synatax of an include file is:
     #include "script"

The script filename is searched relative to the run directory. Its
possible to nest include files to an arbitrary depth. A handy use of
inlcude files is to store often used constants. Use RAM variables of
you don't want these constants written to Output.

     *pi=3.1415926535;
     *h=6.62607095e-34;
     e=2.71828;


File: nco.info,  Node: sort methods,  Next: Irregular grids,  Prev: Include files,  Up: ncap2 netCDF Arithmetic Processor

4.1.16 sort methods
-------------------

In ncap there are two ways to sort. The first is a regular sort. This
sorts ALL the elements of a variable or attribute without regard to any
dimensions. The second method applies a sort map to a variable. To
apply this sort map the size of the variable must be exactly divisible
by the size of the sort map. The method `sort(var_in,&var_map) ' is
overloaded. The second optional argument is a call_by_ref variable
which will hold the sort map.

     a1[$time]={10,2,3,4,6,5,7,3,4,1};
     a1_sort=sort(a1);
     print(a1_sort);
     // 1, 2, 3, 3, 4, 4, 5, 6, 7, 10 ;

     a2[$lon]={2,1,4,3};
     a2_sort=sort(a2,&a2_map);
     print(a2);
     // 1, 2, 3, 4
     print(a2_map);
     // 1, 0, 3, 2 ;

   If the map variable doesn't exist prior to the sort call, then it
will be created with the same shape as the input variable and be of
type `NC_INT'. If the map variable already exists, then the only
restriction is that it be of at least the same size as the input
variable. To apply a map use ` dsort(var_in,var_map)'.

     defdim("nlat",5);

     a3[$lon]={2,5,3,7};
     a4[$nlat,$lon]={
      1, 2, 3, 4,
      5, 6, 7, 8,
      9,10,11,12,
      13,14,15,16,
      17,18,19,20};

     a3_sort=sort(a3,&a3_map);

     print(a3_map);
     // 0, 2, 1, 3 ;

     a5_sort=dsort(a5,a3_map);
     print(a5_sort);
     //  1, 3, 2, 4,
     //  5, 7, 6, 8,
     //  9,11,10,12,
     //  13,15,14,16,
     //  17,19,18,20 ;

     a3_map2[$nlat]={4,3,0,2,1 };

     a5_sort2=dsort(a5,a3_map2);
     print(a5_sort2);
     // 3, 5, 4, 2, 1
     // 8, 10, 9,7, 6,
     // 13,15,14,12,11,
     // 18,20,19,17,16

   As in the above example you a free to create your own mask. If you
wish to sort in decending order then use the `reverse()' method after
the sort.


File: nco.info,  Node: Irregular grids,  Next: bilinear interpolation,  Prev: sort methods,  Up: ncap2 netCDF Arithmetic Processor

4.1.17 Irregular Grids
----------------------

NCO is capable of analyzing datasets for many different underlying
coordinate grid types.  netCDF was developed for and initially used
with grids comprised of orthogonal dimensions forming a rectangular
coordinate system.  We call such grids _standard_ grids.  It is
increasingly common for datasets to use metadata to describe much more
complex grids.  Let us first define three important coordinate grid
properties: rectangularity, regularity, and fxm.

   Grids are _regular_ if the spacing between adjacent is constant.
For example, a 4-by-5 degree latitude-longitude grid is regular because
the spacings between adjacent latitudes (4 degrees) are constant as are
the (5 degrees) spacings between adjacent longitudes.  Spacing in
_irregular_ grids depends on the location along the coordinate.  Grids
such as Gaussian grids have uneven spacing in latitude (points cluster
near the equator) and so are irregular.

   Grids are _rectangular_ if the number of elements in any dimension
is not a function of any other dimension.  For example, a T42 Gaussian
latitude-longitude grid is rectangular because there are the same
number of longitudes (128) for each of the (64) latitudes.  Grids are
_non-rectangular_ if the elements in any dimension depend on another
dimension.  Non-rectangular grids present many special challenges to
analysis software like NCO.

   Wrapped coordinates (*note Wrapped Coordinates::), such as longitude,
are independent of these grid properties (regularity, rectangularity).

   The preferred NCO technique to analyze data on non-standard
coordinate grids is to create a region mask with `ncap2', and then to
use the mask within `ncap2' for variable-specific processing, and/or
with other operators (e.g., `ncwa', `ncdiff') for entire file
processing.

   Before describing the construction of masks, let us review how
irregularly gridded geoscience data are described.  Say that latitude
and longitude are stored as R-dimensional arrays and the product of the
dimension sizes is the total number of elements N in the other
variables.  Geoscience applications tend to use R=1, R=2, and R=3.

   If the grid is has no simple representation (e.g., discontinuous)
then it makes sense to store all coordinates as 1D arrays with the same
size as the number of grid points.  These gridpoints can be completely
independent of all the other (own weight, area, etc.).

   R=1: lat(number_of_gridpoints) and lon(number_of_gridpoints)

   If the horizontal grid is time-invariant then R=2 is common:

   R=2: lat(south_north,east_west) and lon(south_north,east_west)

   The WRF (Weather and Research Forecast) model uses R=3

   R=3: lat(time,south_north,east_west), lon(time,south_north,east_west)

   and so supports grids that change with time.

   Grids with R > 1 often use missing values to indicated empty points.
For example, so-called "staggered grids" will use fewer east_west
points near the poles and more near the equator. netCDF only accepts
rectangular arrays so space must be allocated for the maximum number of
east_west points at all latitudes. Then the application writes missing
values into the unused points near the poles.

   Let's demonstrate the recommended `ncap2' analysis technique by
constructing a region mask for an R=2 grid.  We wish to find, say, the
mean temperature within [LAT_MIN,LAT_MAX] and [LON_MIN,LON_MAX]:
     ncap2 -s 'mask= (lat >= lat_min && lat <= lat_max) && \
                     (lon >= lon_min && lon <= lon_max);' in.nc out.nc

   Once you have a mask, you can use it on specific variables:
     ncap2 -s 'temperature_avg=(temperature*mask).avg()' in.nc out.nc
   and you can apply it to entire files:
     ncwa -a lat,lon -m mask -w area in.nc out.nc

   You can put this altogether on the command line or in a script, e.g.,
cleaner.
     cat > ncap2.in << EOF
     mask = (lat >= lat_min && lat <= lat_max) && (lon >= lon_min && > lon <= lon_max);
     if(mask.total() > 0){ // Check that mask contains some valid values
       temperature_avg=(temperature*mask).avg(); // Average temperature
       temperature_max=(temperature*mask).max(); // Maximum temperature
     }
     EOF
     ncap2 -S ncap2.in in.nc out.nc

   For the WRF file creating the mask looks like
     mask = (XLAT >= lat_min && XLAT <= lat_max) && (XLONG >= lon_min && > XLONG <= lon_max);

   In practice with WRF it's a bit more complicated because you must
use the global metadata to determine the grid staggering and offsets to
translate XLAT and XLONG into real latitudes and longitudes and missing
points. The WRF grid documentation should describe this.

   A few notes: Irregular regions are the union of arrays
lat/lon_min/max's.  The mask procedure is identical for all R.


File: nco.info,  Node: bilinear interpolation,  Next: GSL special functions,  Prev: Irregular grids,  Up: ncap2 netCDF Arithmetic Processor

4.1.18 bilinear interpolation
-----------------------------

As of version 4.0.0 NCO has internal routines to perform bilinear
interpolation on gridded data sets.
In mathematics, bilinear interpolation is an extension of linear
interpolation for interpolating functions of two variables on a regular
grid. The idea is to perform linear interpolation first in one
direction, and then again in the other direction.
Suppose we have an irregular grid of data `temperature[lat,lon]', with
co-ordinate vars `lat[lat], lon[lon]'. And we wish to find the
temperature at an arbitary point [X,Y]  within the grid. If we can
locate lat_min,lat_max and lon_min,lon_max such that  `lat_min <= X <=
lat_max' and `lon_min <=Y <=lon_max' then we can interpolate in two
dimensions to find the temperature at [X,Y].
the general form of the ncap interpolation function is as follows:-

`var_out=bilinear_interp(grid_in, grid_out, grid_out_x, grid_out_y,
grid_in_x, grid_in_y) '
`grid_in'
     Input function data. Usually a 2D variable. It must be of size
     `grid_in_x.size()*grid_in_y.size()'

`grid_out'
     This variable is the shape of var_out. Usually a 2D variable. It
     must be of size `grid_out_x.size()*grid_out_y.size()'

`grid_out_x'
     X output values

`grid_out_y'
     Y output values

`grid_in_x'
     X input values values. Must be montonic (increasing or decreasing).

`grid_in_y'
     Y input values values. Must be montonic (increasing or decreasing).

Prior to calculations all arguments are converted to type `NC_DOUBLE'.
After calculations `var_out' is converted to the input type of
`grid_in'.
Suppose the first part of an ncap2 script is:

     /****************************************/
     defdim("X",4);
     defdim("Y",5);

     //Temperature
     T_in[$X,$Y]=
      {100, 200, 300, 400, 500,
       101, 202, 303, 404, 505,
       102, 204, 306, 408, 510,
       103, 206, 309, 412, 515.0 };

     //Co-ordinate Vars
     x_in[$X]={ 0.0,1.0,2.0,3.01 };
     y_in[$Y]={ 1.0,2.0,3,4,5 };
     /***************************************/
   Now we interpolate with the following variables:
     /***************************************/
     defdim("Xn",3);
     defdim("Yn",4);
     T_out[$Xn,$Yn]=0.0;
     x_out[$Xn]={0.0,0.02,3.01 };
     y_out[$Yn]={1.1,2.0,3,4 };

     var_out=bilinear_interp(T_in,T_out,x_out,y_out,x_in,y_in);
     print(var_out);
     // 110, 200, 300, 400,
     // 110.022, 200.04, 300.06, 400.08,
     // 113.3, 206, 309, 412 ;
     /***************************************/

   Its possible to use the call to interpolate a single point:

     /***************************************/
     var_out=bilinear_interp(T_in,0.0,3.0,4.99,x_in,y_in);
     print(var_out);
     // 513.920594059406
     /***************************************/

*Wrapping and Extrapolation*
The function `bilinear_interp_wrap()' takes the same arguments as
`bilinear_interp()' but performs wrapping (Y) and extrapolation (X) for
points off the edge of the grid. If the given range of longitude is say
(25-335) and we have a point at 20 degrees-  then the end points of the
range are used for the interpolation. This is what wrapping means.  For
wrapping to occur Y must be longitude and must be in the range (0,360)
or (-180,180). There are no restrictions on the longitude (X) values ,
but typically these are in the range (-90,90).
The follwing ncap script illustrates both wrapping and extrapolation of
end points.
     /****************************************/
     defdim("lat_in",6);
     defdim("lon_in",5);

     // co-ordinate in vars
     lat_in[$lat_in]={ -80,-40,0,30,60.0,85.0 };
     lon_in[$lon_in]={ 30, 110, 190, 270, 350.0 };


     T_in[$lat_in,$lon_in]=
       { 10,40,50,30,15,
         12,43,52,31,16,
         14,46,54,32,17,
         16,49,56,33,18,
         18,52,58,34,19,
         20,55,60,35,20.0 };


     defdim("lat_out",4);
     defdim("lon_out",3);

     // co-ordinate vars
     lat_out[$lat_out]={ -90, 0, 70, 88.0 };
     lon_out[$lon_out]={ 0, 190, 355.0 };

     T_out[$lat_out,$lon_out]=0.0;

     T_out=bilinear_interp_wrap(T_in,T_out,lat_out,lon_out,lat_in,lon_in);
     print(T_out);
     //  13.4375, 49.5, 14.09375,
     //  16.25, 54, 16.625,
     //  19.25, 58.8, 19.325,
     //  20.15, 60.24, 20.135 ;


     /****************************************/


File: nco.info,  Node: GSL special functions,  Next: GSL interpolation,  Prev: bilinear interpolation,  Up: ncap2 netCDF Arithmetic Processor

4.1.19 GSL special functions
----------------------------

As of version 3.9.6 (released January, 2009), NCO can link to the GNU
Scientific Library (GSL).  `ncap' can access most GSL special functions
including Airy, Bessel, error, gamma, beta, hypergeometric, and
Legendre functions and elliptical integrals.  GSL must be version 1.4
or later.  To list the GSL functions available with your NCO build, use
`ncap2 -f | grep ^gsl'.

The function names used by ncap2 mirror their GSL names.  The NCO
wrappers for GSL functions automatically call the error-handling
version of the GSL function when available (1).  This allows NCO to
return a missing value when the GSL library encounters a domain error
or a floating point exception.  The slow-down due to calling the
error-handling version of the GSL numerical functions was found to be
negligible (please let us know if you find otherwise).

Consider the gamma function.
The GSL function prototype is
`int gsl_sf_gamma_e(const double x, gsl_sf_result * result)' The `ncap'
script would be:
     lon_in[lon]={-1,0.1,0,2,0.3};
     lon_out=gsl_sf_gamma(lon_in);
     lon_out= _, 9.5135, 4.5908, 2.9915

The first value is set to `_FillValue' since the gamma function is
undefined for negative integers.  If the input variable has a missing
value then this value is used.  Otherwise, the default double fill
value is used (defined in the netCDF header `netcdf.h' as
`NC_FILL_DOUBLE = 9.969e+36').

Consider a call to a Bessel function with GSL prototype
`int gsl_sf_bessel_Jn_e(int n, double x, gsl_sf_result * result)'

   An `ncap' script would be
     lon_out=gsl_sf_bessel_Jn(2,lon_in);
     lon_out=0.11490, 0.0012, 0.00498, 0.011165
   This computes the Bessel function of order N=2 for every value in
`lon_in'.  The Bessel order argument, an integer, can also be a
non-scalar variable, i.e., an array.
     n_in[lon]={0,1,2,3};
     lon_out=gsl_sf_bessel_Jn(n_in,0.5);
     lon_out= 0.93846, 0.24226, 0.03060, 0.00256

Arguments to GSL wrapper functions in `ncap' must conform to one
another, i.e., they must share the same sub-set of dimensions.  For
example: `three_out=gsl_sf_bessel_Jn(n_in,three_dmn_var_dbl)' is valid
because the variable `three_dmn_var_dbl' has a LON dimension, so `n_in'
in can be broadcast to conform to `three_dmn_var_dbl'.  However
`time_out=gsl_sf_bessel_Jn(n_in,time)' is invalid.

   Consider the elliptical integral with prototype `int
gsl_sf_ellint_RD_e(double x, double y, double z, gsl_mode_t mode,
gsl_sf_result * result)'
     three_out=gsl_sf_ellint_RD(0.5,time,three_dmn_var_dbl);

The three arguments are all conformable so the above `ncap' call is
valid. The mode argument in the function prototype controls the
convergence of the algorithm. It also appears  in the Airy Function
prototypes. It can be set by defining the environment variable
`GSL_PREC_MODE'. If unset it defaults to the value `GSL_PREC_DOUBLE'.
See the GSL manual for more details.
     export GSL_PREC_MODE=0 // GSL_PREC_DOUBLE
     export GSL_PREC_MODE=1 // GSL_PREC_SINGLE
     export GSL_PREC_MODE=2 // GSL_PREC_APPROX

The `ncap' wrappers to the array functions are slightly different. Lets
consider the following gsl prototype
`int gsl_sf_bessel_Jn_array(int nmin, int nmax, double x, double
*result_array)'

     b1=lon.double();
     x=0.5;
     status=gsl_sf_bessel_Jn_array(1,4,x,&b1);
     print(status);
     b1=0.24226, 0.0306, 0.00256, 0.00016 ;
   This calculates the bessel function of x=0.5 for n=1 to 4. The first
three arguments are scalar values. if a non-scalar variable is supplied
as an argument then only the first value is used.The final argument is
the variable where the results go ( note the '&' this indicates a call
by reference). This final argument must be of type `double' and must be
of least size (nmax-nmin+1). If either of these conditions are not met
then then the function will blow out with an error message. The
function/wrapper returns a status flag. Zero indicates success.

Lets look at another array function
`int gsl_sf_legendre_Pl_array( int lmax, double x, double
*result_array);'

     a1=time.double();
     x=0.3;
     status=gsl_sf_legendre_Pl_array(a1.size()-1, x,&a1);
     print(status);

This call calculates P_l(0.3) for l=0..9. Note |x|<=1, otherwise there
will be a domain error. See the GSL documentation for more details.

Below is table detailing what GSL functions have been implemented. This
table is correct for GSL version 1.10. To see what functions are
available on your build run the command `ncap2 -f |grep ^gsl' . To see
this table along with the GSL C function prototypes look at the
spreadsheet *doc/nco_gsl.ods*.
*GSL NAME*                *I*  *NCAP FUNCTION CALL*
gsl_sf_airy_Ai_e          Y    gsl_sf_airy_Ai(dbl_expr)
gsl_sf_airy_Bi_e          Y    gsl_sf_airy_Bi(dbl_expr)
gsl_sf_airy_Ai_scaled_e   Y    gsl_sf_airy_Ai_scaled(dbl_expr)
gsl_sf_airy_Bi_scaled_e   Y    gsl_sf_airy_Bi_scaled(dbl_expr)
gsl_sf_airy_Ai_deriv_e    Y    gsl_sf_airy_Ai_deriv(dbl_expr)
gsl_sf_airy_Bi_deriv_e    Y    gsl_sf_airy_Bi_deriv(dbl_expr)
gsl_sf_airy_Ai_deriv_scaled_eY    gsl_sf_airy_Ai_deriv_scaled(dbl_expr)
gsl_sf_airy_Bi_deriv_scaled_eY    gsl_sf_airy_Bi_deriv_scaled(dbl_expr)
gsl_sf_airy_zero_Ai_e     Y    gsl_sf_airy_zero_Ai(uint_expr)
gsl_sf_airy_zero_Bi_e     Y    gsl_sf_airy_zero_Bi(uint_expr)
gsl_sf_airy_zero_Ai_deriv_eY    gsl_sf_airy_zero_Ai_deriv(uint_expr)
gsl_sf_airy_zero_Bi_deriv_eY    gsl_sf_airy_zero_Bi_deriv(uint_expr)
gsl_sf_bessel_J0_e        Y    gsl_sf_bessel_J0(dbl_expr)
gsl_sf_bessel_J1_e        Y    gsl_sf_bessel_J1(dbl_expr)
gsl_sf_bessel_Jn_e        Y    gsl_sf_bessel_Jn(int_expr,dbl_expr)
gsl_sf_bessel_Jn_array    Y    status=gsl_sf_bessel_Jn_array(int,int,double,&var_out)
gsl_sf_bessel_Y0_e        Y    gsl_sf_bessel_Y0(dbl_expr)
gsl_sf_bessel_Y1_e        Y    gsl_sf_bessel_Y1(dbl_expr)
gsl_sf_bessel_Yn_e        Y    gsl_sf_bessel_Yn(int_expr,dbl_expr)
gsl_sf_bessel_Yn_array    Y    gsl_sf_bessel_Yn_array
gsl_sf_bessel_I0_e        Y    gsl_sf_bessel_I0(dbl_expr)
gsl_sf_bessel_I1_e        Y    gsl_sf_bessel_I1(dbl_expr)
gsl_sf_bessel_In_e        Y    gsl_sf_bessel_In(int_expr,dbl_expr)
gsl_sf_bessel_In_array    Y    status=gsl_sf_bessel_In_array(int,int,double,&var_out)
gsl_sf_bessel_I0_scaled_e Y    gsl_sf_bessel_I0_scaled(dbl_expr)
gsl_sf_bessel_I1_scaled_e Y    gsl_sf_bessel_I1_scaled(dbl_expr)
gsl_sf_bessel_In_scaled_e Y    gsl_sf_bessel_In_scaled(int_expr,dbl_expr)
gsl_sf_bessel_In_scaled_arrayY    staus=gsl_sf_bessel_In_scaled_array(int,int,double,&var_out)
gsl_sf_bessel_K0_e        Y    gsl_sf_bessel_K0(dbl_expr)
gsl_sf_bessel_K1_e        Y    gsl_sf_bessel_K1(dbl_expr)
gsl_sf_bessel_Kn_e        Y    gsl_sf_bessel_Kn(int_expr,dbl_expr)
gsl_sf_bessel_Kn_array    Y    status=gsl_sf_bessel_Kn_array(int,int,double,&var_out)
gsl_sf_bessel_K0_scaled_e Y    gsl_sf_bessel_K0_scaled(dbl_expr)
gsl_sf_bessel_K1_scaled_e Y    gsl_sf_bessel_K1_scaled(dbl_expr)
gsl_sf_bessel_Kn_scaled_e Y    gsl_sf_bessel_Kn_scaled(int_expr,dbl_expr)
gsl_sf_bessel_Kn_scaled_arrayY    status=gsl_sf_bessel_Kn_scaled_array(int,int,double,&var_out)
gsl_sf_bessel_j0_e        Y    gsl_sf_bessel_J0(dbl_expr)
gsl_sf_bessel_j1_e        Y    gsl_sf_bessel_J1(dbl_expr)
gsl_sf_bessel_j2_e        Y    gsl_sf_bessel_j2(dbl_expr)
gsl_sf_bessel_jl_e        Y    gsl_sf_bessel_jl(int_expr,dbl_expr)
gsl_sf_bessel_jl_array    Y    status=gsl_sf_bessel_jl_array(int,double,&var_out)
gsl_sf_bessel_jl_steed_arrayY    gsl_sf_bessel_jl_steed_array
gsl_sf_bessel_y0_e        Y    gsl_sf_bessel_Y0(dbl_expr)
gsl_sf_bessel_y1_e        Y    gsl_sf_bessel_Y1(dbl_expr)
gsl_sf_bessel_y2_e        Y    gsl_sf_bessel_y2(dbl_expr)
gsl_sf_bessel_yl_e        Y    gsl_sf_bessel_yl(int_expr,dbl_expr)
gsl_sf_bessel_yl_array    Y    status=gsl_sf_bessel_yl_array(int,double,&var_out)
gsl_sf_bessel_i0_scaled_e Y    gsl_sf_bessel_I0_scaled(dbl_expr)
gsl_sf_bessel_i1_scaled_e Y    gsl_sf_bessel_I1_scaled(dbl_expr)
gsl_sf_bessel_i2_scaled_e Y    gsl_sf_bessel_i2_scaled(dbl_expr)
gsl_sf_bessel_il_scaled_e Y    gsl_sf_bessel_il_scaled(int_expr,dbl_expr)
gsl_sf_bessel_il_scaled_arrayY    status=gsl_sf_bessel_il_scaled_array(int,double,&var_out)
gsl_sf_bessel_k0_scaled_e Y    gsl_sf_bessel_K0_scaled(dbl_expr)
gsl_sf_bessel_k1_scaled_e Y    gsl_sf_bessel_K1_scaled(dbl_expr)
gsl_sf_bessel_k2_scaled_e Y    gsl_sf_bessel_k2_scaled(dbl_expr)
gsl_sf_bessel_kl_scaled_e Y    gsl_sf_bessel_kl_scaled(int_expr,dbl_expr)
gsl_sf_bessel_kl_scaled_arrayY    status=gsl_sf_bessel_kl_scaled_array(int,double,&var_out)
gsl_sf_bessel_Jnu_e       Y    gsl_sf_bessel_Jnu(dbl_expr,dbl_expr)
gsl_sf_bessel_Ynu_e       Y    gsl_sf_bessel_Ynu(dbl_expr,dbl_expr)
gsl_sf_bessel_sequence_Jnu_eN    gsl_sf_bessel_sequence_Jnu
gsl_sf_bessel_Inu_scaled_eY    gsl_sf_bessel_Inu_scaled(dbl_expr,dbl_expr)
gsl_sf_bessel_Inu_e       Y    gsl_sf_bessel_Inu(dbl_expr,dbl_expr)
gsl_sf_bessel_Knu_scaled_eY    gsl_sf_bessel_Knu_scaled(dbl_expr,dbl_expr)
gsl_sf_bessel_Knu_e       Y    gsl_sf_bessel_Knu(dbl_expr,dbl_expr)
gsl_sf_bessel_lnKnu_e     Y    gsl_sf_bessel_lnKnu(dbl_expr,dbl_expr)
gsl_sf_bessel_zero_J0_e   Y    gsl_sf_bessel_zero_J0(uint_expr)
gsl_sf_bessel_zero_J1_e   Y    gsl_sf_bessel_zero_J1(uint_expr)
gsl_sf_bessel_zero_Jnu_e  N    gsl_sf_bessel_zero_Jnu
gsl_sf_clausen_e          Y    gsl_sf_clausen(dbl_expr)
gsl_sf_hydrogenicR_1_e    N    gsl_sf_hydrogenicR_1
gsl_sf_hydrogenicR_e      N    gsl_sf_hydrogenicR
gsl_sf_coulomb_wave_FG_e  N    gsl_sf_coulomb_wave_FG
gsl_sf_coulomb_wave_F_arrayN    gsl_sf_coulomb_wave_F_array
gsl_sf_coulomb_wave_FG_arrayN    gsl_sf_coulomb_wave_FG_array
gsl_sf_coulomb_wave_FGp_arrayN    gsl_sf_coulomb_wave_FGp_array
gsl_sf_coulomb_wave_sphF_arrayN    gsl_sf_coulomb_wave_sphF_array
gsl_sf_coulomb_CL_e       N    gsl_sf_coulomb_CL
gsl_sf_coulomb_CL_array   N    gsl_sf_coulomb_CL_array
gsl_sf_coupling_3j_e      N    gsl_sf_coupling_3j
gsl_sf_coupling_6j_e      N    gsl_sf_coupling_6j
gsl_sf_coupling_RacahW_e  N    gsl_sf_coupling_RacahW
gsl_sf_coupling_9j_e      N    gsl_sf_coupling_9j
gsl_sf_coupling_6j_INCORRECT_eN    gsl_sf_coupling_6j_INCORRECT
gsl_sf_dawson_e           Y    gsl_sf_dawson(dbl_expr)
gsl_sf_debye_1_e          Y    gsl_sf_debye_1(dbl_expr)
gsl_sf_debye_2_e          Y    gsl_sf_debye_2(dbl_expr)
gsl_sf_debye_3_e          Y    gsl_sf_debye_3(dbl_expr)
gsl_sf_debye_4_e          Y    gsl_sf_debye_4(dbl_expr)
gsl_sf_debye_5_e          Y    gsl_sf_debye_5(dbl_expr)
gsl_sf_debye_6_e          Y    gsl_sf_debye_6(dbl_expr)
gsl_sf_dilog_e            N    gsl_sf_dilog
gsl_sf_complex_dilog_xy_e N    gsl_sf_complex_dilog_xy_e
gsl_sf_complex_dilog_e    N    gsl_sf_complex_dilog
gsl_sf_complex_spence_xy_eN    gsl_sf_complex_spence_xy_e
gsl_sf_multiply_e         N    gsl_sf_multiply
gsl_sf_multiply_err_e     N    gsl_sf_multiply_err
gsl_sf_ellint_Kcomp_e     Y    gsl_sf_ellint_Kcomp(dbl_expr)
gsl_sf_ellint_Ecomp_e     Y    gsl_sf_ellint_Ecomp(dbl_expr)
gsl_sf_ellint_Pcomp_e     Y    gsl_sf_ellint_Pcomp(dbl_expr,dbl_expr)
gsl_sf_ellint_Dcomp_e     Y    gsl_sf_ellint_Dcomp(dbl_expr)
gsl_sf_ellint_F_e         Y    gsl_sf_ellint_F(dbl_expr,dbl_expr)
gsl_sf_ellint_E_e         Y    gsl_sf_ellint_E(dbl_expr,dbl_expr)
gsl_sf_ellint_P_e         Y    gsl_sf_ellint_P(dbl_expr,dbl_expr,dbl_expr)
gsl_sf_ellint_D_e         Y    gsl_sf_ellint_D(dbl_expr,dbl_expr,dbl_expr)
gsl_sf_ellint_RC_e        Y    gsl_sf_ellint_RC(dbl_expr,dbl_expr)
gsl_sf_ellint_RD_e        Y    gsl_sf_ellint_RD(dbl_expr,dbl_expr,dbl_expr)
gsl_sf_ellint_RF_e        Y    gsl_sf_ellint_RF(dbl_expr,dbl_expr,dbl_expr)
gsl_sf_ellint_RJ_e        Y    gsl_sf_ellint_RJ(dbl_expr,dbl_expr,dbl_expr,dbl_expr)
gsl_sf_elljac_e           N    gsl_sf_elljac
gsl_sf_erfc_e             Y    gsl_sf_erfc(dbl_expr)
gsl_sf_log_erfc_e         Y    gsl_sf_log_erfc(dbl_expr)
gsl_sf_erf_e              Y    gsl_sf_erf(dbl_expr)
gsl_sf_erf_Z_e            Y    gsl_sf_erf_Z(dbl_expr)
gsl_sf_erf_Q_e            Y    gsl_sf_erf_Q(dbl_expr)
gsl_sf_hazard_e           Y    gsl_sf_hazard(dbl_expr)
gsl_sf_exp_e              Y    gsl_sf_exp(dbl_expr)
gsl_sf_exp_e10_e          N    gsl_sf_exp_e10
gsl_sf_exp_mult_e         Y    gsl_sf_exp_mult(dbl_expr,dbl_expr)
gsl_sf_exp_mult_e10_e     N    gsl_sf_exp_mult_e10
gsl_sf_expm1_e            Y    gsl_sf_expm1(dbl_expr)
gsl_sf_exprel_e           Y    gsl_sf_exprel(dbl_expr)
gsl_sf_exprel_2_e         Y    gsl_sf_exprel_2(dbl_expr)
gsl_sf_exprel_n_e         Y    gsl_sf_exprel_n(int_expr,dbl_expr)
gsl_sf_exp_err_e          Y    gsl_sf_exp_err(dbl_expr,dbl_expr)
gsl_sf_exp_err_e10_e      N    gsl_sf_exp_err_e10
gsl_sf_exp_mult_err_e     N    gsl_sf_exp_mult_err
gsl_sf_exp_mult_err_e10_e N    gsl_sf_exp_mult_err_e10
gsl_sf_expint_E1_e        Y    gsl_sf_expint_E1(dbl_expr)
gsl_sf_expint_E2_e        Y    gsl_sf_expint_E2(dbl_expr)
gsl_sf_expint_En_e        Y    gsl_sf_expint_En(int_expr,dbl_expr)
gsl_sf_expint_E1_scaled_e Y    gsl_sf_expint_E1_scaled(dbl_expr)
gsl_sf_expint_E2_scaled_e Y    gsl_sf_expint_E2_scaled(dbl_expr)
gsl_sf_expint_En_scaled_e Y    gsl_sf_expint_En_scaled(int_expr,dbl_expr)
gsl_sf_expint_Ei_e        Y    gsl_sf_expint_Ei(dbl_expr)
gsl_sf_expint_Ei_scaled_e Y    gsl_sf_expint_Ei_scaled(dbl_expr)
gsl_sf_Shi_e              Y    gsl_sf_Shi(dbl_expr)
gsl_sf_Chi_e              Y    gsl_sf_Chi(dbl_expr)
gsl_sf_expint_3_e         Y    gsl_sf_expint_3(dbl_expr)
gsl_sf_Si_e               Y    gsl_sf_Si(dbl_expr)
gsl_sf_Ci_e               Y    gsl_sf_Ci(dbl_expr)
gsl_sf_atanint_e          Y    gsl_sf_atanint(dbl_expr)
gsl_sf_fermi_dirac_m1_e   Y    gsl_sf_fermi_dirac_m1(dbl_expr)
gsl_sf_fermi_dirac_0_e    Y    gsl_sf_fermi_dirac_0(dbl_expr)
gsl_sf_fermi_dirac_1_e    Y    gsl_sf_fermi_dirac_1(dbl_expr)
gsl_sf_fermi_dirac_2_e    Y    gsl_sf_fermi_dirac_2(dbl_expr)
gsl_sf_fermi_dirac_int_e  Y    gsl_sf_fermi_dirac_int(int_expr,dbl_expr)
gsl_sf_fermi_dirac_mhalf_eY    gsl_sf_fermi_dirac_mhalf(dbl_expr)
gsl_sf_fermi_dirac_half_e Y    gsl_sf_fermi_dirac_half(dbl_expr)
gsl_sf_fermi_dirac_3half_eY    gsl_sf_fermi_dirac_3half(dbl_expr)
gsl_sf_fermi_dirac_inc_0_eY    gsl_sf_fermi_dirac_inc_0(dbl_expr,dbl_expr)
gsl_sf_lngamma_e          Y    gsl_sf_lngamma(dbl_expr)
gsl_sf_lngamma_sgn_e      N    gsl_sf_lngamma_sgn
gsl_sf_gamma_e            Y    gsl_sf_gamma(dbl_expr)
gsl_sf_gammastar_e        Y    gsl_sf_gammastar(dbl_expr)
gsl_sf_gammainv_e         Y    gsl_sf_gammainv(dbl_expr)
gsl_sf_lngamma_complex_e  N    gsl_sf_lngamma_complex
gsl_sf_taylorcoeff_e      Y    gsl_sf_taylorcoeff(int_expr,dbl_expr)
gsl_sf_fact_e             Y    gsl_sf_fact(uint_expr)
gsl_sf_doublefact_e       Y    gsl_sf_doublefact(uint_expr)
gsl_sf_lnfact_e           Y    gsl_sf_lnfact(uint_expr)
gsl_sf_lndoublefact_e     Y    gsl_sf_lndoublefact(uint_expr)
gsl_sf_lnchoose_e         N    gsl_sf_lnchoose
gsl_sf_choose_e           N    gsl_sf_choose
gsl_sf_lnpoch_e           Y    gsl_sf_lnpoch(dbl_expr,dbl_expr)
gsl_sf_lnpoch_sgn_e       N    gsl_sf_lnpoch_sgn
gsl_sf_poch_e             Y    gsl_sf_poch(dbl_expr,dbl_expr)
gsl_sf_pochrel_e          Y    gsl_sf_pochrel(dbl_expr,dbl_expr)
gsl_sf_gamma_inc_Q_e      Y    gsl_sf_gamma_inc_Q(dbl_expr,dbl_expr)
gsl_sf_gamma_inc_P_e      Y    gsl_sf_gamma_inc_P(dbl_expr,dbl_expr)
gsl_sf_gamma_inc_e        Y    gsl_sf_gamma_inc(dbl_expr,dbl_expr)
gsl_sf_lnbeta_e           Y    gsl_sf_lnbeta(dbl_expr,dbl_expr)
gsl_sf_lnbeta_sgn_e       N    gsl_sf_lnbeta_sgn
gsl_sf_beta_e             Y    gsl_sf_beta(dbl_expr,dbl_expr)
gsl_sf_beta_inc_e         N    gsl_sf_beta_inc
gsl_sf_gegenpoly_1_e      Y    gsl_sf_gegenpoly_1(dbl_expr,dbl_expr)
gsl_sf_gegenpoly_2_e      Y    gsl_sf_gegenpoly_2(dbl_expr,dbl_expr)
gsl_sf_gegenpoly_3_e      Y    gsl_sf_gegenpoly_3(dbl_expr,dbl_expr)
gsl_sf_gegenpoly_n_e      N    gsl_sf_gegenpoly_n
gsl_sf_gegenpoly_array    Y    gsl_sf_gegenpoly_array
gsl_sf_hyperg_0F1_e       Y    gsl_sf_hyperg_0F1(dbl_expr,dbl_expr)
gsl_sf_hyperg_1F1_int_e   Y    gsl_sf_hyperg_1F1_int(int_expr,int_expr,dbl_expr)
gsl_sf_hyperg_1F1_e       Y    gsl_sf_hyperg_1F1(dbl_expr,dbl_expr,dbl_expr)
gsl_sf_hyperg_U_int_e     Y    gsl_sf_hyperg_U_int(int_expr,int_expr,dbl_expr)
gsl_sf_hyperg_U_int_e10_e N    gsl_sf_hyperg_U_int_e10
gsl_sf_hyperg_U_e         Y    gsl_sf_hyperg_U(dbl_expr,dbl_expr,dbl_expr)
gsl_sf_hyperg_U_e10_e     N    gsl_sf_hyperg_U_e10
gsl_sf_hyperg_2F1_e       Y    gsl_sf_hyperg_2F1(dbl_expr,dbl_expr,dbl_expr,dbl_expr)
gsl_sf_hyperg_2F1_conj_e  Y    gsl_sf_hyperg_2F1_conj(dbl_expr,dbl_expr,dbl_expr,dbl_expr)
gsl_sf_hyperg_2F1_renorm_eY    gsl_sf_hyperg_2F1_renorm(dbl_expr,dbl_expr,dbl_expr,dbl_expr)
gsl_sf_hyperg_2F1_conj_renorm_eY    gsl_sf_hyperg_2F1_conj_renorm(dbl_expr,dbl_expr,dbl_expr,dbl_expr)
gsl_sf_hyperg_2F0_e       Y    gsl_sf_hyperg_2F0(dbl_expr,dbl_expr,dbl_expr)
gsl_sf_laguerre_1_e       Y    gsl_sf_laguerre_1(dbl_expr,dbl_expr)
gsl_sf_laguerre_2_e       Y    gsl_sf_laguerre_2(dbl_expr,dbl_expr)
gsl_sf_laguerre_3_e       Y    gsl_sf_laguerre_3(dbl_expr,dbl_expr)
gsl_sf_laguerre_n_e       Y    gsl_sf_laguerre_n(int_expr,dbl_expr,dbl_expr)
gsl_sf_lambert_W0_e       Y    gsl_sf_lambert_W0(dbl_expr)
gsl_sf_lambert_Wm1_e      Y    gsl_sf_lambert_Wm1(dbl_expr)
gsl_sf_legendre_Pl_e      Y    gsl_sf_legendre_Pl(int_expr,dbl_expr)
gsl_sf_legendre_Pl_array  Y    status=gsl_sf_legendre_Pl_array(int,double,&var_out)
gsl_sf_legendre_Pl_deriv_arrayN    gsl_sf_legendre_Pl_deriv_array
gsl_sf_legendre_P1_e      Y    gsl_sf_legendre_P1(dbl_expr)
gsl_sf_legendre_P2_e      Y    gsl_sf_legendre_P2(dbl_expr)
gsl_sf_legendre_P3_e      Y    gsl_sf_legendre_P3(dbl_expr)
gsl_sf_legendre_Q0_e      Y    gsl_sf_legendre_Q0(dbl_expr)
gsl_sf_legendre_Q1_e      Y    gsl_sf_legendre_Q1(dbl_expr)
gsl_sf_legendre_Ql_e      Y    gsl_sf_legendre_Ql(int_expr,dbl_expr)
gsl_sf_legendre_Plm_e     Y    gsl_sf_legendre_Plm(int_expr,int_expr,dbl_expr)
gsl_sf_legendre_Plm_array Y    status=gsl_sf_legendre_Plm_array(int,int,double,&var_out)
gsl_sf_legendre_Plm_deriv_arrayN    gsl_sf_legendre_Plm_deriv_array
gsl_sf_legendre_sphPlm_e  Y    gsl_sf_legendre_sphPlm(int_expr,int_expr,dbl_expr)
gsl_sf_legendre_sphPlm_arrayY    status=gsl_sf_legendre_sphPlm_array(int,int,double,&var_out)
gsl_sf_legendre_sphPlm_deriv_arrayN    gsl_sf_legendre_sphPlm_deriv_array
gsl_sf_legendre_array_sizeN    gsl_sf_legendre_array_size
gsl_sf_conicalP_half_e    Y    gsl_sf_conicalP_half(dbl_expr,dbl_expr)
gsl_sf_conicalP_mhalf_e   Y    gsl_sf_conicalP_mhalf(dbl_expr,dbl_expr)
gsl_sf_conicalP_0_e       Y    gsl_sf_conicalP_0(dbl_expr,dbl_expr)
gsl_sf_conicalP_1_e       Y    gsl_sf_conicalP_1(dbl_expr,dbl_expr)
gsl_sf_conicalP_sph_reg_e Y    gsl_sf_conicalP_sph_reg(int_expr,dbl_expr,dbl_expr)
gsl_sf_conicalP_cyl_reg_e Y    gsl_sf_conicalP_cyl_reg(int_expr,dbl_expr,dbl_expr)
gsl_sf_legendre_H3d_0_e   Y    gsl_sf_legendre_H3d_0(dbl_expr,dbl_expr)
gsl_sf_legendre_H3d_1_e   Y    gsl_sf_legendre_H3d_1(dbl_expr,dbl_expr)
gsl_sf_legendre_H3d_e     Y    gsl_sf_legendre_H3d(int_expr,dbl_expr,dbl_expr)
gsl_sf_legendre_H3d_array N    gsl_sf_legendre_H3d_array
gsl_sf_legendre_array_sizeN    gsl_sf_legendre_array_size
gsl_sf_log_e              Y    gsl_sf_log(dbl_expr)
gsl_sf_log_abs_e          Y    gsl_sf_log_abs(dbl_expr)
gsl_sf_complex_log_e      N    gsl_sf_complex_log
gsl_sf_log_1plusx_e       Y    gsl_sf_log_1plusx(dbl_expr)
gsl_sf_log_1plusx_mx_e    Y    gsl_sf_log_1plusx_mx(dbl_expr)
gsl_sf_mathieu_a_array    N    gsl_sf_mathieu_a_array
gsl_sf_mathieu_b_array    N    gsl_sf_mathieu_b_array
gsl_sf_mathieu_a          N    gsl_sf_mathieu_a
gsl_sf_mathieu_b          N    gsl_sf_mathieu_b
gsl_sf_mathieu_a_coeff    N    gsl_sf_mathieu_a_coeff
gsl_sf_mathieu_b_coeff    N    gsl_sf_mathieu_b_coeff
gsl_sf_mathieu_ce         N    gsl_sf_mathieu_ce
gsl_sf_mathieu_se         N    gsl_sf_mathieu_se
gsl_sf_mathieu_ce_array   N    gsl_sf_mathieu_ce_array
gsl_sf_mathieu_se_array   N    gsl_sf_mathieu_se_array
gsl_sf_mathieu_Mc         N    gsl_sf_mathieu_Mc
gsl_sf_mathieu_Ms         N    gsl_sf_mathieu_Ms
gsl_sf_mathieu_Mc_array   N    gsl_sf_mathieu_Mc_array
gsl_sf_mathieu_Ms_array   N    gsl_sf_mathieu_Ms_array
gsl_sf_pow_int_e          N    gsl_sf_pow_int
gsl_sf_psi_int_e          Y    gsl_sf_psi_int(int_expr)
gsl_sf_psi_e              Y    gsl_sf_psi(dbl_expr)
gsl_sf_psi_1piy_e         Y    gsl_sf_psi_1piy(dbl_expr)
gsl_sf_complex_psi_e      N    gsl_sf_complex_psi
gsl_sf_psi_1_int_e        Y    gsl_sf_psi_1_int(int_expr)
gsl_sf_psi_1_e            Y    gsl_sf_psi_1(dbl_expr)
gsl_sf_psi_n_e            Y    gsl_sf_psi_n(int_expr,dbl_expr)
gsl_sf_synchrotron_1_e    Y    gsl_sf_synchrotron_1(dbl_expr)
gsl_sf_synchrotron_2_e    Y    gsl_sf_synchrotron_2(dbl_expr)
gsl_sf_transport_2_e      Y    gsl_sf_transport_2(dbl_expr)
gsl_sf_transport_3_e      Y    gsl_sf_transport_3(dbl_expr)
gsl_sf_transport_4_e      Y    gsl_sf_transport_4(dbl_expr)
gsl_sf_transport_5_e      Y    gsl_sf_transport_5(dbl_expr)
gsl_sf_sin_e              N    gsl_sf_sin
gsl_sf_cos_e              N    gsl_sf_cos
gsl_sf_hypot_e            N    gsl_sf_hypot
gsl_sf_complex_sin_e      N    gsl_sf_complex_sin
gsl_sf_complex_cos_e      N    gsl_sf_complex_cos
gsl_sf_complex_logsin_e   N    gsl_sf_complex_logsin
gsl_sf_sinc_e             N    gsl_sf_sinc
gsl_sf_lnsinh_e           N    gsl_sf_lnsinh
gsl_sf_lncosh_e           N    gsl_sf_lncosh
gsl_sf_polar_to_rect      N    gsl_sf_polar_to_rect
gsl_sf_rect_to_polar      N    gsl_sf_rect_to_polar
gsl_sf_sin_err_e          N    gsl_sf_sin_err
gsl_sf_cos_err_e          N    gsl_sf_cos_err
gsl_sf_angle_restrict_symm_eN    gsl_sf_angle_restrict_symm
gsl_sf_angle_restrict_pos_eN    gsl_sf_angle_restrict_pos
gsl_sf_angle_restrict_symm_err_eN    gsl_sf_angle_restrict_symm_err
gsl_sf_angle_restrict_pos_err_eN    gsl_sf_angle_restrict_pos_err
gsl_sf_zeta_int_e         Y    gsl_sf_zeta_int(int_expr)
gsl_sf_zeta_e             Y    gsl_sf_zeta(dbl_expr)
gsl_sf_zetam1_e           Y    gsl_sf_zetam1(dbl_expr)
gsl_sf_zetam1_int_e       Y    gsl_sf_zetam1_int(int_expr)
gsl_sf_hzeta_e            Y    gsl_sf_hzeta(dbl_expr,dbl_expr)
gsl_sf_eta_int_e          Y    gsl_sf_eta_int(int_expr)
gsl_sf_eta_e              Y    gsl_sf_eta(dbl_expr)

   ---------- Footnotes ----------

   (1) These are the GSL standard function names postfixed with `_e'.
NCO calls these functions automatically, without the NCO command having
to specifically indicate the `_e' function suffix.


File: nco.info,  Node: GSL interpolation,  Next: GSL least-squares fitting,  Prev: GSL special functions,  Up: ncap2 netCDF Arithmetic Processor

4.1.20 GSL interpolation
------------------------

As of version 3.9.9 (released July, 2009), NCO has wrappers to the GSL
interpolation functions.

Given a set of data points (x1,y1)...(xn, yn) the GSL functions
computes a continuous interpolating function Y(x) such that Y(xi) = yi.
The interpolation is piecewise smooth, and its behavior at the
end-points is determined by the type of interpolation used. For more
information consult the GSL manual.

Interpolation with `ncap2' is a two stage process. In the first stage,
a ram variable is created from the chosen interpolating function and
the data set. This ram variable holds in memory a GSL interpolation
object. In the second stage, points along the interpolating function
are calculated. If you have a very large data set or are interpolating
many sets then consider deleting the ram variable when it is redundant.
Use the command `ram_delete(var_nm)'.

A simple example

     x_in[$lon]={1.0,2.0,3.0,4.0};
     y_in[$lon]={1.1,1.2,1.5,1.8};

     // Ram variable is declared and defined here
     gsl_interp_cspline(&ram_sp,x_in,y_in);

     x_out[$lon_grd]={1.1,2.0,3.0,3.1,3.99};

     y_out=gsl_spline_eval(ram_sp,x_out);
     y2=gsl_spline_eval(ram_sp,1.3);
     y3=gsl_spline_eval(ram_sp,0.0);
     ram_delete(ram_sp);

     print(y_out);   // 1.10472, 1.2, 1.4, 1.42658, 1.69680002
     print(y2);      // 1.12454
     print(y3);      // '_'

Note in the above example y3 is set to 'missing value' because 0.0
isn't within the input X range.

   * GSL Interpolation Types *
All the interpolation functions have been implemented. These are:
gsl_interp_linear()
gsl_interp_polynomial()
gsl_interp_cspline()
gsl_interp_cspline_periodic()
gsl_interp_akima()
gsl_interp_akima_periodic()
* Evaluation of Interpolating Types *
*Implemented*
gsl_spline_eval()
*Unimplemented*
gsl_spline_deriv()
gsl_spline_deriv2()
gsl_spline_integ()

File: nco.info,  Node: GSL least-squares fitting,  Next: GSL statistics,  Prev: GSL interpolation,  Up: ncap2 netCDF Arithmetic Processor

4.1.21 GSL least-squares fitting
--------------------------------

Least Squares fitting is a method of calculating a straight line
through a set of experimental data points in the XY plane. The data
maybe weighted or unweighted. For more information please refer to the
GSL manual.

These GSL functions fall into three categories:
*A)* Fitting data to Y=c0+c1*X
*B)* Fitting data (through the origin) Y=c1*X
*C)* Multi-parameter fitting (not yet implemented)
*Section A*
`status=*gsl_fit_linear*(data_x,stride_x,data_y,stride_y,n,&co,&c1,&cov00,&cov01,&cov11,&sumsq)
'

*Input variables*: data_x, stride_x, data_y, stride_y, n
From the above variables an X and Y vector both of length 'n' are
derived.  If data_x or data_y is less than type double then it is
converted to type `double'.  It is up to you to do bounds checking on
the input data.  For example if stride_x=3 and n=8 then the size of
data_x must be at least 24

*Output variables*: c0, c1, cov00, cov01, cov11,sumsq
The '&' prefix indicates that these are call-by-reference variables.
If any of the output variables don't exist prior to the call then they
are created on the fly as scalar variables of type `double'. If they
already exist then their existing value is overwritten. If the function
call is successful then `status=0'.

   `status=
*gsl_fit_wlinear*(data_x,stride_x,data_w,stride_w,data_y,stride_y,n,&co,&c1,&cov00,&cov01,&cov11,&chisq)
'

Similar to the above call except it creates an additional weighting
vector from the variables data_w, stride_w, n

   ` data_y_out=*gsl_fit_linear_est*(data_x,c0,c1,cov00,cov01,cov11) '

This function calculates y values along the line Y=c0+c1*X
*Section B*
`status=*gsl_fit_mul*(data_x,stride_x,data_y,stride_y,n,&c1,&cov11,&sumsq)
'

*Input variables*: data_x, stride_x, data_y, stride_y, n
From the above variables an X and Y vector both of length 'n' are
derived.  If data_x or data_y is less than type `double' then it is
converted to type `double'.
*Output variables*: c1,cov11,sumsq
`status=
*gsl_fit_wmul*(data_x,stride_x,data_w,stride_w,data_y,stride_y,n,&c1,&cov11,&sumsq)
'

Similar to the above call except it creates an additional weighting
vector from the variables data_w, stride_w, n

   ` data_y_out=*gsl_fit_mul_est*(data_x,c0,c1,cov11) '

This function calculates y values along the line Y=c1*X
The below example shows *gsl_fit_linear()* in action

     defdim("d1",10);
     xin[d1]={1,2,3,4,5,6,7,8,9,10.0};
     yin[d1]={3.1,6.2,9.1,12.2,15.1,18.2,21.3,24.0,27.0,30.0};
     gsl_fit_linear(xin,1,yin,1,$d1.size,&c0,&c1,&cov00,&cov01,&cov11,&sumsq);
     print(c0);  // 0.2
     print(c1);  // 2.98545454545


     defdim("e1",4);
     xout[e1]={1.0,3.0,4.0,11};
     yout[e1]=0.0;

     yout=gsl_fit_linear_est(xout, c0,c1, cov00,cov01, cov11, sumsq);

     print(yout);  // 3.18545454545 ,9.15636363636, ,12.1418181818 ,33.04


File: nco.info,  Node: GSL statistics,  Next: GSL random number generation,  Prev: GSL least-squares fitting,  Up: ncap2 netCDF Arithmetic Processor

4.1.22 GSL statistics
---------------------

Wrappers for most of the GSL Statistical functions have been
implemented. The GSL function names include a type specifier (except
for type double functions). To obtain the equivalent NCO name simply
remove the type specifier; then depending on the data type the
appropriate GSL function  is called. The weighed statistical functions
e.g ` gsl_stats_wvariance()' are only defined in GSL for floating point
types; so your data must of type `float' or `double' otherwise ncap2
will emit an error message. To view the implemented functions use the
shell command `ncap2 -f|grep _stats'

GSL Functions
     short gsl_stats_max (short data[], size_t stride, size_t n);
     double gsl_stats_int_mean (int data[], size_t stride, size_t n);
     double gsl_stats_short_sd_with_fixed_mean (short data[], size_t stride, size_t n, double mean);
     double gsl_stats_wmean (double w[], size_t wstride, double data[], size_t stride, size_t n);
     double gsl_stats_quantile_from_sorted_data (double sorted_data[], size_t stride, size_t n, double f) ;

Equivalent ncap2 wrapper functions
     short gsl_stats_max (var_data, data_stride, n);
     double gsl_stats_mean (var_data, data_stride, n);
     double gsl_stats_sd_with_fixed_mean (var_data, data_stride, n, var_mean);
     double gsl_stats_wmean (var_weight, weight_stride, var_data, data_stride, n, var_mean);
     double gsl_stats_quantile_from_sorted_data (var_sorted_data, data_stride, n, var_f) ;

GSL has no notion of missing values or dimensionality beyond one. If
your data has missing values which you want ignored in the calculations
then use the `ncap2' built in aggregate functions( *note Methods and
functions:: ). The GSL functions operate on a vector of values created
from the var_data/stride/n arguments. The ncap wrappers check that
there is no bounding error with regard to the size of the data and the
final value in the vector.

   Some examples

     a1[time]={1,2,3,4,5,6,7,8,9,10 };

     a1_avg=gsl_stats_mean(a1,1,10);
     print(a1_avg); // 5.5

     a1_var=gsl_stats_variance(a1,4,3);
     print(a1_var); // 16.0

     // bounding error, vector attempts to access element a1(10)
     a1_sd=gsl_stats_sd(a1,5,3);

For functions with the signature  *func_nm(var_data, data_stride, n)*
you can omit the second or third arguments. The default value for
stride is `1'. The default value for n is ` 1+ (data.size()-1)/stride'

     // the following are equvalent
     n2=gsl_stats_max(a1,1,10)
     n2=gsl_stats_max(a1,1);
     n2=gsl_stats_max(a1);

     // the following are equivalent
     n3=gsl_stats_median_from_sorted_data(a1,2,5);
     n3=gsl_stats_median_from_sorted_data(a1,2);

     // the following are NOT equivalent
     n4=gsl_stats_kurtosis(a1,3,2);
     n4=gsl_stats_kurtosis(a1,3); //default n=4

The following example illustrates some of the weighted functions in
action. The data is randomly generated. In this case the value of the
weight for each datum is either 0.0 or 1.0

     defdim("r1",2000);
     data[r1]=1.0;

     // fill with ramdon numbers [0.0,10.0)
     data=10.0*gsl_rng_uniform(data);

     // Create a weighting var
     weight=(data>4.0);

     wmean=gsl_stats_wmean(weight,1,data,1,$r1.size);
     print(wmean);

     wsd=gsl_stats_wsd(weight,1,data,1,$r1.size);
     print(wsd);

     // number of values in data that are greater than 4
     weight_size=weight.total();
     print(weight_size);

     // print min/max of data
     dmin=data.gsl_stats_min();
     dmax=data.gsl_stats_max();
     print(dmin);print(dmax);


File: nco.info,  Node: GSL random number generation,  Next: Examples ncap2,  Prev: GSL statistics,  Up: ncap2 netCDF Arithmetic Processor

4.1.23 GSL random number generation
-----------------------------------

The GSL library has a large number of random number generators. In
addition there are a large set of functions for turning uniform random
numbers into discrete or continuous probabilty distributions. The
random number generator algorithms vary in terms of quality numbers
output, speed of execution and maximium number output. For more
information see the GSL documentation. The algorithm and seed are set
via environment variables, these are picked up by the `ncap2' code.

*Setup*
The number algorithm is set by the environment variable `GSL_RNG_TYPE'.
If this variable isn't set then the default rng algorithm is
gsl_rng_19937. The seed is set with the environment variable
`GSL_RNG_SEED'. The following wrapper functions in ncap2 provide
information about the chosen algorithm.
`gsl_rng_min()'
     the minimium value returned by the rng algorithm.

`gsl_rng_max()'
     the maximium value returned by the rng algorithm.

*Uniformly Distributed Random Numbers*
`gsl_rng_get(var_in)'
     This function returns var_in with integers from the chosen rng
     algorithm. The min and max values depend uoon the chosen rng
     algorthm.

`gsl_rng_uniform_int(var_in)'
     This function returns var_in with random integers from 0 to n-1.
     The value n must be less than or equal to the maximium value of
     the chosen rng algorithm.

`gsl_rng_uniform(var_in)'
     This function returns var_in with double precision numbers in the
     range [0.0,1). The range include 0.0 but excludes 1.0.

`gsl_rng_uniform_pos(var_in)'
     This function returns var_in with double precision numbers in the
     range (0.0,1) - excluding both 0.0 and 1.0.

Below are examples of `gsl_rng_get()' and `gsl_rng_uniform_int()' in
action.

     export GSL_RNG_TYPE=ranlux
     export GSL_RNG_SEED=10
     ncap2 -v -O -s 'a1[time]=0;a2=gsl_rng_get(a1);' in.nc foo.nc
     // 10 random numbers from the range 0 - 16777215
     // a2=9056646, 12776696, 1011656, 13354708, 5139066, 1388751, 11163902, 7730127, 15531355, 10387694 ;

     ncap2 -v -O -s 'a1[time]=21;a2=gsl_rng_uniform_int(a1).sort();' in.nc foo.nc
     // 10 random numbers from the range 0 - 20
     a2 = 1, 1, 6, 9, 11, 13, 13, 15, 16, 19 ;

The following example produces an `ncap2' runtime error. This is
because the chose rng algorithm has a maximium value greater than `
NC_MAX_INT=2147483647 '; the wrapper functions to `gsl_rng_get()' and
`gsl_rng_uniform_int()' return variable of type `NC_INT'. Please be
aware of this when using random number distribution functions functions
from the GSL library which return `unsigned int'. Examples of these are
`gsl_ran_geometric()' and `gsl_ran_pascal()'.

     export GSL_RNG_TYPE=mt19937
     ncap2 -v -O -s 'a1[time]=0;a2=gsl_rng_get(a1);' in.nc foo.nc

To find the maximium value of the chosen rng algorithm use the
following code snippet.
     ncap2 -v -O -s 'rng_max=gsl_rng_max();print(rng_max)' in.nc foo.nc

*Random Number Distributions*
The GSL library has a rich set of random number disribution functions.
The library also provides cumulative distribution functions and inverse
cumulative distribution functions sometimes referred to a quantile
functions. To see whats available on your build use the shell command
`ncap2 -f|grep -e _ran -e _cdf'.

The following examples  all return variables of type `NC_INT'
     defdim("out",15);
     a1[$out]=0.5;
     a2=gsl_ran_binomial(a1,30).sort();
     //a2 = 10, 11, 12, 12, 13, 14, 14, 15, 15, 16, 16, 16, 16, 17, 22 ;
     a3=gsl_ran_geometric(a2).sort();
     //a2 = 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 3, 4, 5 ;
     a4=gsl_ran_pascal(a2,50);
     //a5 = 37, 40, 40, 42, 43, 45, 46, 49, 52, 58, 60, 62, 62, 65, 67 ;

The following all return variables of type `NC_DOUBLE';

     defdim("b1",1000);
     b1[$b1]=0.8;
     b2=gsl_ran_exponential(b1);
     b2_avg=b2.avg();
     print(b2_avg);
     // b2_avg = 0.756047976787

     b3=gsl_ran_gaussian(b1);
     b3_avg=b3.avg();
     b3_rms=b3.rms();
     print(b3_avg);
     // b3_avg= -0.00903446534258 ;
     print(b3_rms);
     // b3_rms= 0.81162979889 ;

     b4[$b1]=10.0;
     b5[$b1]=20.0;
     b6=gsl_ran_flat(b4,b5);
     b6_avg=b6.avg();
     print(b6_avg);
     // b6_avg=15.0588129413


File: nco.info,  Node: Examples ncap2,  Next: Intrinsic mathematical methods,  Prev: GSL random number generation,  Up: ncap2 netCDF Arithmetic Processor

4.1.24 Examples ncap2
---------------------

See the `ncap.in' and `ncap2.in' scripts released with NCO for more
complete demonstrations of `ncap' and `ncap2' functionality,
respectively (these scripts are available on-line at
`http://nco.sf.net/ncap.in' and `http://nco.sf.net/ncap2.in').

   Define new attribute NEW for existing variable ONE as twice the
existing attribute DOUBLE_ATT of variable ATT_VAR:
     ncap2 -s 'one@new=2*att_var@double_att' in.nc out.nc

   Average variables of mixed types (result is of type `double'):
     ncap2 -s 'average=(var_float+var_double+var_int)/3' in.nc out.nc

   Multiple commands may be given to `ncap2' in three ways.  First, the
commands may be placed in a script which is executed, e.g., `tst.nco'.
Second, the commands may be individually specified with multiple `-s'
arguments to the same `ncap2' invocation.  Third, the commands may be
chained together into a single `-s' argument to `ncap2'.  Assuming the
file `tst.nco' contains the commands `a=3;b=4;c=sqrt(a^2+b^2);', then
the following `ncap2' invocations produce identical results:
     ncap2 -v -S tst.nco in.nc out.nc
     ncap2 -v -s 'a=3' -s 'b=4' -s 'c=sqrt(a^2+b^2)' in.nc out.nc
     ncap2 -v -s 'a=3;b=4;c=sqrt(a^2+b^2)' in.nc out.nc
   The second and third examples show that `ncap2' does not require
that a trailing semi-colon `;' be placed at the end of a `-s' argument,
although a trailing semi-colon `;' is always allowed.  However,
semi-colons are required to separate individual assignment statements
chained together as a single `-s' argument.

   `ncap2' may be used to "grow" dimensions, i.e., to increase
dimension sizes without altering existing data.  Say `in.nc' has
`ORO(lat,lon)' and the user wishes a new file with
`new_ORO(new_lat,new_lon)' that contains zeros in the undefined
portions of the new grid.
     defdim("new_lat",$lat.size+1); // Define new dimension sizes
     defdim("new_lon",$lon.size+1);
     new_ORO[$new_lat,$new_lon]=0.0f; // Initialize to zero
     new_ORO(0:$lat.size-1,0:$lon.size-1)=ORO; // Fill valid data
   The commands to define new coordinate variables `new_lat' and
`new_lon' in the output file follow a similar pattern.  One would might
store these commands in a script `grow.nco' and then execute the script
with
     ncap2 -v -S grow.nco in.nc out.nc

   Imagine you wish to create a binary flag based on the value of an
array.  The flag should have value 1.0 where the array exceeds 1.0, and
value 0.0 elsewhere.  This example creates the binary flag `ORO_flg' in
`out.nc' from the continuous array named `ORO' in `in.nc'.
     ncap2 -s 'ORO_flg=(ORO > 1.0)' in.nc out.nc
   Suppose your task is to change all values of `ORO' which equal 2.0
to the new value 3.0:
     ncap2 -s 'ORO_msk=(ORO==2.0);ORO=ORO_msk*3.0+!ORO_msk*ORO' in.nc out.nc
   This creates and uses `ORO_msk' to mask the subsequent arithmetic
operation.  Values of `ORO' are only changed where `ORO_msk' is true,
i.e., where `ORO' equals 2.0
Using the `where' statement the above code simplifies to :
     ncap2 -s 'where(ORO==2.0) ORO=3.0;' in.nc foo.nc

   This example uses `ncap2' to compute the covariance of two variables.
Let the variables U and V be the horizontal wind components.  The
"covariance" of U and V is defined as the time mean product of the
deviations of U and V from their respective time means.  Symbolically,
the covariance

   [U'V'] = [UV]-[U][V] where [X] denotes the time-average of X and X'

   denotes the deviation from the time-mean.  The covariance tells us
how much of the correlation of two signals arises from the signal
fluctuations versus the mean signals.  Sometimes this is called the
"eddy covariance".  We will store the covariance in the variable
`uprmvprm'.
     ncwa -O -a time -v u,v in.nc foo.nc # Compute time mean of u,v
     ncrename -O -v u,uavg -v v,vavg foo.nc # Rename to avoid conflict
     ncks -A -v uavg,vavg foo.nc in.nc # Place time means with originals
     ncap2 -O -s 'uprmvprm=u*v-uavg*vavg' in.nc in.nc # Covariance
     ncra -O -v uprmvprm in.nc foo.nc # Time-mean covariance
   The mathematically inclined will note that the same covariance would
be obtained by replacing the step involving `ncap2' with
     ncap2 -O -s 'uprmvprm=(u-uavg)*(v-vavg)' foo.nc foo.nc # Covariance

   As of NCO version 3.1.8 (December, 2006), `ncap2' can compute
averages, and thus covariances, by itself:
     ncap2 -s 'uavg=u.avg($time);vavg=v.avg($time);uprmvprm=u*v-uavg*vavg' \
           -s 'uprmvrpmavg=uprmvprm.avg($time)' in.nc foo.nc
   We have not seen a simpler method to script and execute powerful
arithmetic than `ncap2'.

   `ncap2' utilizes many meta-characters (e.g., `$', `?', `;', `()',
`[]') that can confuse the command-line shell if not quoted properly.
The issues are the same as those which arise in utilizing extended
regular expressions to subset variables (*note Subsetting Variables::).
The example above will fail with no quotes and with double quotes.
This is because shell globbing tries to "interpolate" the value of
`$time' from the shell environment unless it is quoted:
     ncap2 -s 'uavg=u.avg($time)'  in.nc foo.nc # Correct (recommended)
     ncap2 -s  uavg=u.avg('$time') in.nc foo.nc # Correct (and dangerous)
     ncap2 -s  uavg=u.avg($time)   in.nc foo.nc # Fails ($time = '')
     ncap2 -s "uavg=u.avg($time)"  in.nc foo.nc # Fails ($time = '')
   Without the single quotes, the shell replaces `$time' with an empty
string.  The command `ncap2' receives from the shell is `uavg=u.avg()'.
This causes `ncap2' to average over all dimensions rather than just the
TIME dimension, and unintended consequence.

   We recommend using single quotes to protect `ncap2' command-line
scripts from the shell, even when such protection is not strictly
necessary.  Expert users may violate this rule to exploit the ability
to use shell variables in `ncap2' command-line scripts (*note CCSM
Example::).  In such cases it may be necessary to use the shell
backslash character `\' to protect the `ncap2' meta-character.

   Whether a degenerate record dimension is desirable or undesirable
depends on the application.  Often a degenerate TIME dimension is
useful, e.g., for concatentating, but it may cause problems with
arithmetic.  Such is the case in the above example, where the first
step employs `ncwa' rather than `ncra' for the time-averaging.  Of
course the numerical results are the same with both operators.  The
difference is that, unless `-b' is specified, `ncwa' writes no TIME
dimension to the output file, while `ncra' defaults to keeping TIME as
a degenerate (size 1) dimension.  Appending `u' and `v' to the output
file would cause `ncks' to try to expand the degenerate time axis of
`uavg' and `vavg' to the size of the non-degenerate TIME dimension in
the input file.  Thus the append (`ncks -A') command would be undefined
(and should fail) in this case.  Equally important is the `-C' argument
(*note Subsetting Coordinate Variables::) to `ncwa' to prevent any
scalar TIME variable from being written to the output file.  Knowing
when to use `ncwa -a time' rather than the default `ncra' for
time-averaging takes, well, time.


File: nco.info,  Node: Intrinsic mathematical methods,  Next: Operators precedence and associativity,  Prev: Examples ncap2,  Up: ncap2 netCDF Arithmetic Processor

4.1.25 Intrinsic mathematical methods
-------------------------------------

`ncap2' supports the standard mathematical functions supplied with most
operating systems.  Standard calculator notation is used for addition
`+', subtraction `-', multiplication `*', division `/', exponentiation
`^', and modulus `%'.  The available elementary mathematical functions
are: 
`abs(x)'
     "Absolute value" Absolute value of X.  Example: abs(-1) = 1

`acos(x)'
     "Arc-cosine" Arc-cosine of X where X is specified in radians.
     Example: acos(1.0) = 0.0

`acosh(x)'
     "Hyperbolic arc-cosine" Hyperbolic arc-cosine of X where X is
     specified in radians.  Example: acosh(1.0) = 0.0

`asin(x)'
     "Arc-sine" Arc-sine of X where X is specified in radians.  Example:
     asin(1.0) = 1.57079632679489661922

`asinh(x)'
     "Hyperbolic arc-sine" Hyperbolic arc-sine of X where X is
     specified in radians.  Example: asinh(1.0) = 0.88137358702

`atan(x)'
     "Arc-tangent" Arc-tangent of X where X is specified in radians
     between -pi/2 and pi/2.  Example: atan(1.0) =
     0.78539816339744830961

`atan2(y,x)'
     "Arc-tangent2" Arc-tangent of Y/X :Example atan2(1,3) =
     0.321689857

`atanh(x)'
     "Hyperbolic arc-tangent" Hyperbolic arc-tangent of X where X is
     specified in radians between -pi/2 and pi/2.  Example:
     atanh(3.14159265358979323844) = 1.0

`ceil(x)'
     "Ceil" Ceiling of X. Smallest integral value not less than
     argument.  Example: ceil(0.1) = 1.0

`cos(x)'
     "Cosine" Cosine of X where X is specified in radians.  Example:
     cos(0.0) = 1.0

`cosh(x)'
     "Hyperbolic cosine" Hyperbolic cosine of X where X is specified in
     radians.  Example: cosh(0.0) = 1.0

`erf(x)'
     "Error function" Error function of X where X is specified between
     -1 and 1.  Example: erf(1.0) = 0.842701

`erfc(x)'
     "Complementary error function" Complementary error function of X
     where X is specified between -1 and 1.  Example: erfc(1.0) =
     0.15729920705

`exp(x)'
     "Exponential" Exponential of X, e^x.  Example: exp(1.0) =
     2.71828182845904523536

`floor(x)'
     "Floor" Floor of X. Largest integral value not greater than
     argument.  Example: floor(1.9) = 1

`gamma(x)'
     "Gamma function" Gamma function of X, Gamma(x).  The well-known
     and loved continuous factorial function.  Example: gamma(0.5) =
     sqrt(pi)

`gamma_inc_P(x)'
     "Incomplete Gamma function" Incomplete Gamma function of parameter
     A and variable X, gamma_inc_P(a,x).  One of the four incomplete
     gamma functions.  Example: gamma_inc_P(1,1) = 1-1/e

`ln(x)'
     "Natural Logarithm" Natural logarithm of X, ln(x).  Example:
     ln(2.71828182845904523536) = 1.0

`log(x)'
     "Natural Logarithm" Exact synonym for `ln(x)'.

`log10(x)'
     "Base 10 Logarithm" Base 10 logarithm of X, log10(x).  Example:
     log(10.0) = 1.0

`nearbyint(x)'
     "Round inexactly" Nearest integer to X is returned in floating
     point format.  No exceptions are raised for "inexact conversions".
     Example: nearbyint(0.1) = 0.0

`pow(x,y)'
     "Power" Value of X is raised to the power of Y.  Exceptions are
     raised for "domain errors".  Due to type-limitations in the
     C language `pow' function, integer arguments are promoted (*note
     Type Conversion::) to type `NC_FLOAT' before evaluation.  Example:
     pow(2,3) = 8

`rint(x)'
     "Round exactly" Nearest integer to X is returned in floating point
     format.  Exceptions are raised for "inexact conversions".  Example:
     rint(0.1) = 0

`round(x)'
     "Round" Nearest integer to X is returned in floating point format.
     Round halfway cases away from zero, regardless of current IEEE
     rounding direction.  Example: round(0.5) = 1.0

`sin(x)'
     "Sine" Sine of X where X is specified in radians.  Example:
     sin(1.57079632679489661922) = 1.0

`sinh(x)'
     "Hyperbolic sine" Hyperbolic sine of X where X is specified in
     radians.  Example: sinh(1.0) = 1.1752

`sqrt(x)'
     "Square Root" Square Root of X, sqrt(x).  Example: sqrt(4.0) = 2.0

`tan(x)'
     "Tangent" Tangent of X where X is specified in radians.  Example:
     tan(0.78539816339744830961) = 1.0

`tanh(x)'
     "Hyperbolic tangent" Hyperbolic tangent of X where X is specified
     in radians.  Example: tanh(1.0) = 0.761594155956

`trunc(x)'
     "Truncate" Nearest integer to X is returned in floating point
     format.  Round halfway cases toward zero, regardless of current
     IEEE rounding direction.  Example: trunc(0.5) = 0.0
   The complete list of mathematical functions supported is
platform-specific.  Functions mandated by ANSI C are _guaranteed_ to be
present and are indicated with an asterisk (1).  and are indicated with
an asterisk.  Use the `-f' (or `fnc_tbl' or `prn_fnc_tbl') switch to
print a complete list of functions supported on your platform.  (2)



   ---------- Footnotes ----------

   (1) ANSI C compilers are guaranteed to support double precision
versions of these functions.  These functions normally operate on
netCDF variables of type `NC_DOUBLE' without having to perform
intrinsic conversions.  For example, ANSI compilers provide `sin' for
the sine of C-type `double' variables.  The ANSI standard does not
require, but many compilers provide, an extended set of mathematical
functions that apply to single (`float') and quadruple (`long double')
precision variables.  Using these functions (e.g., `sinf' for `float',
`sinl' for `long double'), when available, is (presumably) more
efficient than casting variables to type `double', performing the
operation, and then re-casting.  NCO uses the faster intrinsic
functions when they are available, and uses the casting method when
they are not.

   (2) Linux supports more of these intrinsic functions than other OSs.


File: nco.info,  Node: Operators precedence and associativity,  Next: ID Quoting,  Prev: Intrinsic mathematical methods,  Up: ncap2 netCDF Arithmetic Processor

4.1.26 Operators precedence and associativity
---------------------------------------------

This page lists the `ncap' operators in order of precedence (highest to
lowest). Their associativity indicates in what order operators of equal
precedence in an expression are applied.

Operator      Description                                   Associativity
--------------------------------------------------------------------------- 
`++ --'       Postfix Increment/Decrement                   Right to Left
`()'          Parentheses (function call)                   
`.'           Method call                                   

`++ --'       Prefix Increment/Decrement                    Right to Left
`+ -'         Unary  Plus/Minus                             
`!'           Logical Not                                   

`^'           Power of Operator                             Right to Left

`* / %'       Multiply/Divide/Modulus                       Left To Right

`+ -'         Addition/Subtraction                          Left To Right

`>> <<'       Fortran style array clipping                  Left to Right


`< <='        Less than/Less than or equal to               Left to Right
`> >='        Greater than/Greater than or equal to         

`== !='       Equal to/Not equal to                         Left to Right

`&&'          Logical AND                                   Left to Right

`||'          Logical OR                                    Left to Right

`?:'          Ternary Operator                              Right to Left

`='           Assignment                                    Right to Left
`+= -='       Addition/subtraction assignment               
`*= /='       Multiplication/division assignment            


File: nco.info,  Node: ID Quoting,  Prev: Operators precedence and associativity,  Up: ncap2 netCDF Arithmetic Processor

4.1.27 ID Quoting
-----------------

In this section when I refer to a name I mean a variable name,
attribute name or a dimension name The allowed characters in a valid
netCDF name vary from release to release. (See end section). If you
want to use metacharacters in a name or use a method name as a variable
name then the name has to be quoted wherever it occurs.

The default nco name is specified by the regular expressions:

     DGT:     ('0'..'9');
     LPH:     ( 'a'..'z' | 'A'..'Z' | '_' );
     name:    (LPH)(LPH|DGT)+

The first character of a valid name must be alphabetic or the
underscore. Any subsequent characters must be alphanumeric or
underscore. ( e.g a1,_23, hell_is_666 )

The valid characters in a quoted name are specified by the regular
expressions:

     LPHDGT:  ( 'a'..'z' | 'A'..'Z' | '_' | '0'..'9');
     name:    (LPHDGT|'-'|'+'|'.'|'('|')'|':' )+  ;

Quote a variable:
'avg' , '10_+10','set_miss' '+-90field' , '-test'=10.0d
Quote a attribute:
'three@10', 'set_mss@+10', '666@hell', 't1@+units'="kelvin"
Quote a dimension:
'$10', '$t1-', '$-odd', c1['$10','$t1-']=23.0d

The following comments are lifted directly from the netcdf libraries
and detail the naming conventions for each release.

netcdf-3.5.1
netcdf-3.6.0-p1
netcdf-3.6.1
netcdf-3.6.2
     /*
      * ( [a-zA-Z]|[0-9]|'_'|'-'|'+'|'.'|'|':'|'@'|'('|')' )+
      * Verify that a name string is valid
      * CDL syntax, eg, all the characters are
      * alphanumeric, '-', '_', '+', or '.'.
      * Also permit ':', '@', '(', or ')' in names for chemists currently making
      * use of these characters, but don't document until ncgen and ncdump can
      * also handle these characters in names.
      */

netcdf-3.6.3
netcdf-4.0 Final  2008/08/28
     /*
      * Verify that a name string is valid syntax.  The allowed name
      * syntax (in RE form) is:
      *
      * ([a-zA-Z_]|{UTF8})([^\x00-\x1F\x7F/]|{UTF8})*
      *
      * where UTF8 represents a multibyte UTF-8 encoding.  Also, no
      * trailing spaces are permitted in names.  This definition
      * must be consistent with the one in ncgen.l.  We do not allow '/'
      * because HDF5 does not permit slashes in names as slash is used as a
      * group separator.  If UTF-8 is supported, then a multi-byte UTF-8
      * character can occur anywhere within an identifier.  We later
      * normalize UTF-8 strings to NFC to facilitate matching and queries.
      */


File: nco.info,  Node: ncatted netCDF Attribute Editor,  Next: ncbo netCDF Binary Operator,  Prev: ncap2 netCDF Arithmetic Processor,  Up: Operator Reference Manual

4.2 `ncatted' netCDF Attribute Editor
=====================================

SYNTAX
     ncatted [-a ATT_DSC] [-a ...] [-D DBG] [-h] [--hdr_pad NBR]
     [-l PATH] [-O] [-o OUTPUT-FILE] [-p PATH] [-R] [-r]
     INPUT-FILE [[OUTPUT-FILE]]

DESCRIPTION

   `ncatted' edits attributes in a netCDF file.  If you are editing
attributes then you are spending too much time in the world of
metadata, and `ncatted' was written to get you back out as quickly and
painlessly as possible.  `ncatted' can "append", "create", "delete",
"modify", and "overwrite" attributes (all explained below).
Furthermore, `ncatted' allows each editing operation to be applied to
every variable in a file.  This saves time when changing attribute
conventions throughout a file.  Note that `ncatted' interprets
character attributes (i.e., attributes of type `NC_CHAR') as strings.

   Because repeated use of `ncatted' can considerably increase the size
of the `history' global attribute (*note History Attribute::), the `-h'
switch is provided to override automatically appending the command to
the `history' global attribute in the OUTPUT-FILE.

   When `ncatted' is used to change the `_FillValue' attribute, it
changes the associated missing data self-consistently.  If the internal
floating point representation of a missing value, e.g., 1.0e36, differs
between two machines then netCDF files produced on those machines will
have incompatible missing values.  This allows `ncatted' to change the
missing values in files from different machines to a single value so
that the files may then be concatenated together, e.g., by `ncrcat',
without losing any information.  *Note Missing Values::, for more
information.

   The key to mastering `ncatted' is understanding the meaning of the
structure describing the attribute modification, ATT_DSC specified by
the required option `-a' or `--attribute'.  Each ATT_DSC contains five
elements, which makes using `ncatted' somewhat complicated, but
powerful.  The ATT_DSC argument structure contains five arguments in the
following order:
ATT_DSC = ATT_NM, VAR_NM, MODE, ATT_TYPE, ATT_VAL
ATT_NM
     Attribute name.  Example: `units'

VAR_NM
     Variable name.  Regular expressions (*note Subsetting Variables::)
     are accepted and will select any matching variable names.
     Example: `pressure', `'^H2O''.

MODE
     Edit mode abbreviation.  Example: `a'.  See below for complete
     listing of valid values of MODE.

ATT_TYPE
     Attribute type abbreviation.  Example: `c'.  See below for
     complete listing of valid values of ATT_TYPE.

ATT_VAL
     Attribute value.  Example: `pascal'.
There should be no empty space between these five consecutive arguments.
The description of these arguments follows in their order of appearance.

   The value of ATT_NM is the name of the attribute you want to edit.
This meaning of this should be clear to all users of the `ncatted'
operator.  If ATT_NM is omitted (i.e., left blank) and "Delete" mode is
selected, then all attributes associated with the specified variable
will be deleted.

   The value of VAR_NM is the name of the variable containing the
attribute (named ATT_NM) that you want to edit.  There are three very
important and useful exceptions to this rule.  The value of VAR_NM can
also be used to direct `ncatted' to edit global attributes, or to
repeat the editing operation for every variable in a file.  A value of
VAR_NM of "global" indicates that ATT_NM refers to a global attribute,
rather than a particular variable's attribute.  This is the method
`ncatted' supports for editing global attributes.  If VAR_NM is left
blank, on the other hand, then `ncatted' attempts to perform the
editing operation on every variable in the file.  This option may be
convenient to use if you decide to change the conventions you use for
describing the data.  Finally, as mentioned above, VAR_NM may be
specified as a regular expression.

   The value of MODE is a single character abbreviation (`a', `c', `d',
`m', or `o') standing for one of five editing modes:
`a'
     "Append".  Append value ATT_VAL to current VAR_NM attribute ATT_NM
     value ATT_VAL, if any.  If VAR_NM does not have an attribute
     ATT_NM, there is no effect.

`c'
     "Create".  Create variable VAR_NM attribute ATT_NM with ATT_VAL if
     ATT_NM does not yet exist.  If VAR_NM already has an attribute
     ATT_NM, there is no effect.

`d'
     "Delete".  Delete current VAR_NM attribute ATT_NM.  If VAR_NM does
     not have an attribute ATT_NM, there is no effect.  If ATT_NM is
     omitted (left blank), then all attributes associated with the
     specified variable are automatically deleted.  When "Delete" mode
     is selected, the ATT_TYPE and ATT_VAL arguments are superfluous
     and may be left blank.

`m'
     "Modify".  Change value of current VAR_NM attribute ATT_NM to value
     ATT_VAL.  If VAR_NM does not have an attribute ATT_NM, there is no
     effect.

`o'
     "Overwrite".  Write attribute ATT_NM with value ATT_VAL to variable
     VAR_NM, overwriting existing attribute ATT_NM, if any.  This is
     the default mode.

   The value of ATT_TYPE is a single character abbreviation (`f', `d',
`l', `i', `s', `c', `b', `u') or a short string standing for one of the
twelve primitive netCDF data types:
`f'
     "Float".  Value(s) specified in ATT_VAL will be stored as netCDF
     intrinsic type `NC_FLOAT'.

`d'
     "Double".  Value(s) specified in ATT_VAL will be stored as netCDF
     intrinsic type `NC_DOUBLE'.

`i, l'
     "Integer" or "Long".  Value(s) specified in ATT_VAL will be stored
     as netCDF intrinsic type `NC_INT'.

`s'
     "Short".  Value(s) specified in ATT_VAL will be stored as netCDF
     intrinsic type `NC_SHORT'.

`c'
     "Char".  Value(s) specified in ATT_VAL will be stored as netCDF
     intrinsic type `NC_CHAR'.

`b'
     "Byte".  Value(s) specified in ATT_VAL will be stored as netCDF
     intrinsic type `NC_BYTE'.

`ub'
     "Unsigned Byte".  Value(s) specified in ATT_VAL will be stored as
     netCDF intrinsic type `NC_UBYTE'.

`us'
     "Unsigned Short".  Value(s) specified in ATT_VAL will be stored as
     netCDF intrinsic type `NC_USHORT'.

`u, ui, ul'
     "Unsigned Int".  Value(s) specified in ATT_VAL will be stored as
     netCDF intrinsic type `NC_UINT'.

`ll, int64'
     "Int64".  Value(s) specified in ATT_VAL will be stored as netCDF
     intrinsic type `NC_INT64'.

`ull, uint64'
     "Uint64".  Value(s) specified in ATT_VAL will be stored as netCDF
     intrinsic type `NC_UINT64'.

`sng'
     "String".  Value(s) specified in ATT_VAL will be stored as netCDF
     intrinsic type `NC_STRING'.
The specification of ATT_TYPE is optional (and is ignored) in "Delete"
mode.

   The value of ATT_VAL is what you want to change attribute ATT_NM to
contain.  The specification of ATT_VAL is optional in "Delete" (and is
ignored) mode.  Attribute values for all types besides `NC_CHAR' must
have an attribute length of at least one.  Thus ATT_VAL may be a single
value or one-dimensional array of elements of type `att_type'.  If the
ATT_VAL is not set or is set to empty space, and the ATT_TYPE is
`NC_CHAR', e.g., `-a units,T,o,c,""' or `-a units,T,o,c,', then the
corresponding attribute is set to have zero length.  When specifying an
array of values, it is safest to enclose ATT_VAL in single or double
quotes, e.g., `-a levels,T,o,s,"1,2,3,4"' or `-a
levels,T,o,s,'1,2,3,4''.  The quotes are strictly unnecessary around
ATT_VAL except when ATT_VAL contains characters which would confuse the
calling shell, such as spaces, commas, and wildcard characters.

   NCO processing of `NC_CHAR' attributes is a bit like Perl in that it
attempts to do what you want by default (but this sometimes causes
unexpected results if you want unusual data storage).  If the ATT_TYPE
is `NC_CHAR' then the argument is interpreted as a string and it may
contain C-language escape sequences, e.g., `\n', which NCO will
interpret before writing anything to disk.  NCO translates valid escape
sequences and stores the appropriate ASCII code instead.  Since two
byte escape sequences, e.g., `\n', represent one-byte ASCII codes,
e.g., ASCII 10 (decimal), the stored string attribute is one byte
shorter than the input string length for each embedded escape sequence.
The most frequently used C-language escape sequences are `\n' (for
linefeed) and `\t' (for horizontal tab).  These sequences in particular
allow convenient editing of formatted text attributes.  The other valid
ASCII codes are `\a', `\b', `\f', `\r', `\v', and `\\'.  *Note ncks
netCDF Kitchen Sink::, for more examples of string formatting (with the
`ncks' `-s' option) with special characters.

   Analogous to `printf', other special characters are also allowed by
`ncatted' if they are "protected" by a backslash.  The characters `"',
`'', `?', and `\' may be input to the shell as `\"', `\'', `\?', and
`\\'.  NCO simply strips away the leading backslash from these
characters before editing the attribute.  No other characters require
protection by a backslash.  Backslashes which precede any other
character (e.g., `3', `m', `$', `|', `&', `@', `%', `{', and `}') will
not be filtered and will be included in the attribute.

   Note that the NUL character `\0' which terminates C language strings
is assumed and need not be explicitly specified.  If `\0' is input, it
will not be translated (because it would terminate the string in an
additional location).  Because of these context-sensitive rules, if
wish to use an attribute of type `NC_CHAR' to store data, rather than
text strings, you should use `ncatted' with care.

EXAMPLES

   Append the string "Data version 2.0.\n" to the global attribute
`history':
     ncatted -a history,global,a,c,"Data version 2.0\n" in.nc
   Note the use of embedded C language `printf()'-style escape
sequences.

   Change the value of the `long_name' attribute for variable `T' from
whatever it currently is to "temperature":
     ncatted -a long_name,T,o,c,temperature in.nc

   Delete all existing `units' attributes:
     ncatted -a units,,d,, in.nc
   The value of VAR_NM was left blank in order to select all variables
in the file.  The values of ATT_TYPE and ATT_VAL were left blank because
they are superfluous in "Delete" mode.

   Delete all attributes associated with the `tpt' variable:
     ncatted -a ,tpt,d,, in.nc
   The value of ATT_NM was left blank in order to select all attributes
associated with the variable.  To delete all global attributes, simply
replace `tpt' with `global' in the above.

   Modify all existing `units' attributes to "meter second-1":
     ncatted -a units,,m,c,"meter second-1" in.nc

   Add a `units' attribute of "kilogram kilogram-1" to all variables
whose first three characters are `H2O':
     ncatted -a units,'^H2O',c,c,"kilogram kilogram-1" in.nc

   Overwrite the `quanta' attribute of variable `energy' to an array of
four integers.
     ncatted -O -a quanta,energy,o,s,"010,101,111,121" in.nc

   As of NCO 3.9.6 (January, 2009), variable names arguments to
`ncatted' may contain "extended regular expressions".  Create `isotope'
attributes for all variables containing `H2O' in their names.
     ncatted -O -a isotope,'^H2O*',c,s,"18" in.nc
   See *note Subsetting Variables:: for more details.

   Demonstrate input of C-language escape sequences (e.g., `\n') and
other special characters (e.g., `\"')
     ncatted -h -a special,global,o,c,
     '\nDouble quote: \"\nTwo consecutive double quotes: \"\"\n
     Single quote: Beyond my shell abilities!\nBackslash: \\\n
     Two consecutive backslashes: \\\\\nQuestion mark: \?\n' in.nc
   Note that the entire attribute is protected from the shell by single
quotes.  These outer single quotes are necessary for interactive use,
but may be omitted in batch scripts.

